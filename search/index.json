[{"content":"Shell 이란? Shell은 운영체제에서 사용자가 입력하는 명령을 읽고 해석하여 대신 실행해주는 프로그램이다.\nUnix 계열 운영체제의 종류로는 bash, zbash, csh 등이 있고, Windows 운영체제에서는 CMD, Power Shell 등이 있다.\n본 게시글에서는 CLI Shell만 설명합니다.\nShell Script 란? Shell Script는 텍스트 형식으로 저장되는 프로그램이고 한 줄씩 순차적으로 읽어 명령어룰 수행하는 프로그램이라고 할 수 있다.\n자주 사용하는 명령어 조합을 텍스트 형식으로 저장해두면 매 번 번거롭게 입력할 필요 없이 실행을 하는 것만으로 명령어들을 자동화하여 사용할 수 있는 장점이 있다.\nShell 중 bash를 이용하여 예제 작성 우선 Shell의 많은 종류 중에서 bash를 채택하게 된 이유는 간단하다.\nUnix계열에서 가장 널리 사용되고 있다. 그 중 가장 많이 사용되는 OS인 CentOS, MacOS에서 사용하는 Command와 통용되기 때문이다. Windows 환경에서도 Git을 설치할 때 같이 설치되는 Git Bash를 이용하면 되기 때문에 제약이 적다. bash를 통해 Git Commit을 반자동화 해보자 우리는 Hugo Framework를 사용하면서 하나의 프로젝트 당 2개의 Git Repository로 관리한다.\n프로젝트의 모든 파일을 저장하는 Repository (개발 Repo) 프로젝트로 만들어진 산출물을 저장하는 Repository (배포 Repo) 위와 같이 2개의 Repo를 관리하다 보니 프로젝트의 수정 사항이 생길 때 마다 2개의 Repo에 각각 commit \u0026amp; push를 진행하여야 했다. 이를 조금 더 생산적으로 처리할 수 없을까? 라는 고민을 하다가 Shell Script를 떠올리게 되었다.\nGit에 commit하는 방법은 여러 가지가 있지만 대부분 편집기에 연동하여 사용하거나 CLI Command를 이용하여 commit을 진행하는 경우가 많다보니 Shell Script를 이용하여 commit 과정을 Command로 작성해두면 한 번의 파일 실행만으로 2개의 Repo에 commit할 수 있었다.\n사용 예 우선 우리가 사용하는 Hugo Framework의 배포 방식은 링크에 접속하여 확인할 수 있다.\ndeploy.sh 샘플\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash echo \u0026#34;커밋메시지를 입력하세요.\u0026#34; read msg echo \u0026#34;커밋메시지 : $msg\u0026#34; msg = $msg hugo -F cd public git add . git commit -m \u0026#34;$msg\u0026#34; git push origin master cd .. git add . git commit -m \u0026#34;$msg\u0026#34; git push origin master Line 1 : bash shell임을 명시\nLine 3~5 : 커밋메시지를 입력받고 출력해줌\nLine 7 : 입력받은 커밋메시지로 변수 선언 Line 9 : Hugo Framework 빌드 명령어\nLine 11~14 : public 폴더로 접근해 git push\nLine 16~19 : Project 폴더로 접근해 git push\n주의점 deploy.sh파일은 Project 폴더에 존재해야한다. 개발 Repo와 배포 Repo가 각각 git remote와 git submodule이 등록돼있어야 한다. bash 참고 blog.gaerae.com - Bash 입문자를 위한 핵심 요약 정리\n","date":"2022-11-14T08:21:00Z","image":"https://blog.realsn.com/p/shell-script/thumb_hu4b43ad9903583d9b6c0c15712e6fded3_93405_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/shell-script/","title":"Shell Script"},{"content":"Prototype 이란? prototype 단어의 뜻은 원형이라는 뜻을 가지고 있다. 실제로 우리는 시제품, 견본 등의 의미로 사용되며, JS에서 Prototype은 자신을 만들어낸 객체의 원형을 뜻한다.\n쉽게 풀어서 설명한다면? Prototype은 원형(유전자)이다. 객체의 원형 = 객체의 부모가 가지는 유전자 = 상속받은 데이터, 메서드 함수 객체에는 Prototype이라는 특수한 유형의 객체 Property가 존재한다. 이러한 Prototype Property를 통해 생성자 함수는 인스턴스에게 Prototype 객체에 있는 데이터, 메서드를 상속한다. 인스턴스 객체의 key에 접근할 때 해당 객체에게 key가 없다면 상위 Prototype Property에 key가 있는지 확인한다. 상위 Prototype에 key가 존재하지 않으면 계속하여 더 상위 Prototpye에서 찾는다. 이를 Prototype Chain이라고 한다. 참조 1. hanamo.kr - 프로토타입과 프로토타입 체인\n2. mygumi.tistory.com - Javascript: prototype 이란\n3. youtube 코딩애플 - 이거보고 prototype 이해 못하면 강의접음\nPrototype을 이용하여 Plugin 만들기 그럼 위에서 설명한 Prototype을 이용하여 jQuery에 존재하는 wrap()메서드와 unwrap()메서드를 Vanilla JS로 구현해보자\nwrap()과 unwrap()에 대한 설명 wrap()메서드는 매개변수로 받은 태그를 이용하여 선택자로 선택 된 요소를 감싸는 역할을 하고, unwrap()메서드는 선택자로 선택 된 요소의 직상위 요소를 없애는 역할을 한다.\njQuery의 wrap() 샘플 1 2 3 \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 1 $(\u0026#39;#target\u0026#39;).wrap(\u0026#39;\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u0026#39;); 1 2 3 4 5 \u0026lt;section\u0026gt; \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; jQuery의 unwrap() 샘플 1 2 3 4 5 \u0026lt;section\u0026gt; \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 1 $(\u0026#39;#target\u0026#39;).unwrap(); 1 2 3 \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; Vanilla JS로 작성하기 위한 설계 Vanilla JS로 변환하는 과정에서 다방면으로 고민하면서 설계하여야 했고 설계 과정에서 여러 가지 고민이 있었지만 대표적으로는 아래와 같은 고민이 있었다.\nwrap()의 경우에는 요소를 추가하면서\nid 값과 class 값을 부여할지?\n한 번에 여러 개의 요소를 추가할 수 있을지?\nid 값과 class 값은 어떻게 입력받을지? unwrap()의 경우에는 상위를 제거할 때\n형제 요소가 있음을 고려해야하는지?\n있다면 자기 자신만 부모 요소 바깥으로 나가고 형제 요소는 그대로 둘지?\n아니면 자기 자신만 나가고 부모와 함께 형제 요소를 모두 없앨지?\n아니면 자기 자신과 형제를 모두 데리고 나가면서 부모 요소를 없앨지? 그렇게 내린 결론은 wrap()의 경우에는 id, class, 여러 요소 추가가 모두 수용 되었고, id, class 입력은 full tag 형태로 입력받게 설계하였다. unwrap()은 형제 요소가 있음을 고려하되, 형제 요소가 존재하다면 자기 자신과 형제 요소 모두가 부모 요소를 포기하는 형태가 되었다.\nfull tag example 1 \u0026lt;div id=\u0026#34;test\u0026#34; class=\u0026#34;test example\u0026#34;\u0026gt; Vanilla JS로 작성한 wrap() 샘플 1 2 3 \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 1 2 let target = document.querySelector(\u0026#39;#target\u0026#39;); target.wrap(`\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;`); 1 2 3 4 5 \u0026lt;section\u0026gt; \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; Vanilla JS로 작성한 unwrap() 샘플 1 2 3 4 5 \u0026lt;section\u0026gt; \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 1 2 let target = document.querySelector(\u0026#39;#target\u0026#39;); target.unwrap(); 1 2 3 \u0026lt;div id = \u0026#34;target\u0026#34;\u0026gt; \u0026lt;span\u0026gt;example\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; Vanilla JS로 작성한 코드 및 설명 wrap() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Element.prototype.wrap = function(tag) { const isContains = /\\s?id*=*\u0026#34;.*?\u0026#34;|\\s?class*=*\u0026#34;.*?\u0026#34;/gi; const isContainID = /\\s?id*=*\u0026#34;.*?\u0026#34;/gi; const isContainClass = /\\s?class*=*\u0026#34;.*?\u0026#34;/gi; let $target = this; let $tag = tag.replace(/\u0026lt;\\/.*?\u0026gt;/g, \u0026#39;\u0026#39;).replace(/\u0026gt;.*?\u0026lt;/g, \u0026#39;\u0026gt;/\u0026lt;\u0026#39;).split(\u0026#39;/\u0026#39;); $tag.reverse(); let $makeEl = []; $tag.forEach(function(element, idx) { let plainTag = element.replace(/\\s?id*=*\u0026#34;.*?\u0026#34;|\\s?class*=*\u0026#34;.*?\u0026#34;|[\u0026lt;,\u0026gt;]|\\s/gi, \u0026#39;\u0026#39;); $makeEl[idx] = document.createElement(plainTag); if (element.match(isContains)) { if (element.match(isContainID)) $makeEl[idx].id = element.match(isContainID).toString().replace(/\\s?id*=*\u0026#34;|\u0026#34;|\\s/gi,\u0026#39;\u0026#39;); if (element.match(isContainClass)) { let $plainClass = element.match(isContainClass).toString().replace(/\\s?class*=*\u0026#34;|\u0026#34;/gi,\u0026#39;\u0026#39;).split(\u0026#39; \u0026#39;); $plainClass.forEach((insertClass) =\u0026gt; { $makeEl[idx].classList.add(insertClass); }); } } if(idx==0) $makeEl[idx].innerHTML = $target.outerHTML; else $makeEl[idx].innerHTML = $makeEl[idx-1].outerHTML; }); $target.parentElement.insertBefore($makeEl[$tag.length-1], $target); this.remove(); } Line 1 : 요소에 대한 prototype을 추가할거기 때문에 Element.prototype으로 선언\nLine 3~5 : id값이나 class값을 입력받았는지 확인하는 정규식 선언\nLine 7 : $target 변수에 this 할당(this = 선택자로 선택 된 요소)\nLine 8~9 : 매개변수 중에서 닫는 태그(/Element)를 지우고 $tag 변수에 할당(태그가 2개 이상일 수 있기 때문에 배열 형태)\nLine 11 : 순수한 요소를 만들 배열 $makeEl 선언\nLine 13~35 : 입력받은 태그의 갯수 만큼 반복 될 코드블럭\nLine 14~15 : id, calss정보 및 꺽쇠 괄호(\u0026lt;,\u0026gt;)를 모두 지우고 순수한 태그 이름 추출하여 빈 html요소를 만들고$makeEl[idx]에 할당\nLine 17~30 : id 또는 class정보가 있다면 실행 될 코드블럭\nLine 19~20 : id정보가 있다면 정규식을 통하여 id값만 추출하여 위에서 만든 빈 요소에 id값 할당 (1개의 id만 가능)\nLine 22~29 : class정보가 있다면 정규식을 통하여 class값만 추출하여 위에서 만든 빈 요소에 class값 할당(여러 개 있다면 모두 추가)\nLine 32~33 : 여러 개의 요소를 추가할 때 사용하는 일종의 예외처리 Line 37~38 : 위의 forEach를 통하여 만들어낸 요소를 $target 앞에 추가하고 기존의 this를 삭제\nunwrap() 1 2 3 4 5 6 7 8 9 10 11 12 13 Element.prototype.unwrap = function() { let $target = this; let $parentEl = this.parentElement; let $insertTag = \u0026#39;\u0026#39;; for (var i=0; i\u0026lt;$parentEl.children.length; i++) { $insertTag += $parentEl.children[i].outerHTML; } $parentEl.insertAdjacentHTML(\u0026#34;beforebegin\u0026#34;, $insertTag); $parentEl.remove(); } Line 1 : 상기 wrap()과 동일\nLine2~3 : 자기 자신을 $target에 할당, 부요를 $parentEl에 할당\nLine5 : 최종적으로 추가 될 Tag 정보를 담을 변수 $insertTag선언\nLine 7~9 : target의 부모에서 자식의 갯수만큼 반복할 코드 블럭\nLine 8 : $insertTag에 target의 부모에 있는 자식의 모든 html정보 추가\nLine 11~12 : 위에서 만들어낸 $insertTag를 부모 요소 앞에 추가하고 기존의 부모 요소 삭제\n마치며 jQuery는 CSS 선택자를 이용하여 대상을 편하게 선택할 수 있고 여러 편리한 메서드들이 이미 정의 돼있어 사용하기 매우 편한 라이브러리이다. 하지만 순수 자바스크립트에 비해 꽤 여러 가지의 단점이 존재한다. 또한, 오래 전부터 여러 매체에서 들었던 말은 '편리 하지만 순수 자바스크립트보다 성능이 많이 떨어지니 되도록 사용하지 않는게 좋다.'였지만 나는 자바스크립트에 대한 이해도가 깊지 않아 좋은 품질의 코드를 작성할 자신이 없어 jQuery에 많이 의존하던 편이였다.\n하지만, 최근 업무적으로 순수 자바스크립트를 이용한 플러그인을 작성하다보니 모르고 있었던 문법도 알아내고, 기존보다 점점 코드의 품질이 좋아지는게 느껴졌다.\n물론 현재도 완벽하거나 뛰어난 품질의 코드를 작성하지는 못하지만 내가 원했던대로, 설계했던대로 기능이 구현되는 것에 만족하는 수준이기에 꾸준한 학습을 통하여 이번에 작성한 플러그인 및 기존에 작성한 플러그인들에 대한 수정도 필요할 것 같다.\n","date":"2022-11-13T13:50:00Z","image":"https://blog.realsn.com/p/js-prototype/thumb_hubd228537ab0603247c335c0cc6629299_387383_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/js-prototype/","title":"JS Prototype"},{"content":"IntersectionObserver API IntersectionObserver API 는 브라우저의 Viewport와, 지정한 요소 (Element)의 교차점을 관찰하는 기능을 제공합니다. 교차점을 감지해 \u0026lsquo;원하는 위치\u0026rsquo;에 \u0026lsquo;지정한 요소가 노출되고있는지\u0026rsquo;를 확인 가능하며, callback을 통해 기능을 연결 할 수 있습니다. mdn문서에 따르면, 웹이 성숙해짐과 동시에 퍼포먼스를 챙기며 필요한 기능들을 구현하기 위해서는 IntersectionObserver API가 필요하다고 말합니다. 예를 들어 무한 스크롤로 더 많은 콘텐츠가 로드되고 렌더링 되는 웹사이트를 만든다거나, 스크롤 시 노출시킬 컨텐츠 구현 등에서 많은 사용이 필요하겠죠.\naddEventListener(\u0026ldquo;scroll\u0026rdquo;) 과의 차이 scroll 이벤트를 사용하는 것 보다, 해당 문서의 API를 이용해야하는 가장 중요한 이유는 브라우저의 부하를 고려, 한마디로 퍼포먼스를 고려한 스크립트를 위함입니다. mdn 문서 뿐만 아니라, 해당 API를 소개하는 글에서는 입을 모아 말하는 이슈인것 같구요.\n과거에 교차 감지를 구현하려면 Element.getBoundingClientRect()영향을 받는 모든 요소에 필요한 정보를 구축하는 것과 같은 메서드를 호출하는 이벤트 핸들러 및 루프가 필요했습니다. 이 코드는 모두 메인 스레드에서 실행되기 때문에 이 중 하나라도 성능 문제를 일으킬 수 있습니다. 사이트에 이러한 테스트가 로드되면 상황이 완전히 나빠질 수 있습니다.\nMDN의 해당 API 소개글에 나온 위 내용과 같이 기존의 addEventListener 를 통한 \u0026ldquo;scroll\u0026rdquo; 이벤트를 사용할 경우, 메인 스레드에서의 재실행이 반복됨으로서 렌더링 성능이나 이벤트 연속 호출과 같은 문제가 발생합니다. 이와같은 치명적인 허점을 보완하기 위해 나온 JS API가 IntersectionObserver API 입니다. 무엇보다 메인 스레드에서의 실행이 아닌, 브라우저를 감지 후 특정 시점에서 비동기로 실행이 되는 덕에 웹 퍼포먼스에서의 상당한 이득을 볼 수 있습니다.\nIntersectionObserver 사용방법 해당 API 사용시 필요한 내용들입니다.\n이벤트를 실행시킬 element Observer API 에 사용할 options\n2-1) 지정될 ViewPort\n2-2) Viewport에서의 Margin값 ( ViewPort 크기를 임의로 늘이거나, 줄임 )\n2-3) Viewport와 엘리먼트의 교차가 몇 %이어야 API가 감지를 실행하는지에 대한 값. API 선언 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let options = { root: document.querySelector(\u0026#34;#scrollArea\u0026#34;), // default: null rootMargin: \u0026#34;0px\u0026#34;, // 상단 내용에서 말한 2-2, Viewport의 마진값 지정으로 // Viewport의 크기를 늘이거나 줄일수 있습니다. // ★ 단위값 ( px || % )가 필수임. threshold: 1.0, // 상단 내용 2-3, 엘리먼트 백분율 기준 Viewport와의 교차정도를 지정할수 있음. // ex ) threshold: 1.0 == 100% 교차 // ex ) threshold: 0.5 == 50% 교차 // ★ 1 이상의 값은 정의 불가 }; let observer = new IntersectionObserver(callback, options); // API 생성, 지정한 옵션값을 토대로 브라우저를 감지하며, 감지 될 경우 callback 함수 실행 observe 대상 지정하기 먼저 Viewport안에 노출되고있는지 확인하고싶은 대상 엘리먼트를 선언해보고자 합니다. 바로 위 코드블럭의 18번째 줄을 그대로 사용한 후, observe시킬 대상을 연결합니다.\n1 2 let observer = new IntersectionObserver(callback, options); observer.observe(\u0026#34;대상 엘리먼트\u0026#34;); 새로 API를 선언한 후 변수에 담은 후, 그 뒤에 다시 observe 를 연결하여 대상 엘리먼트를 연결합니다. 현재 options 값과 callback시킬 함수가 없어 작동되지 않고 있지만요. 포스팅의 threshold 에서 테스트용 엘리먼트를 불러올 예정입니다.\noptions 값의 rootMargin 기본적으로 px 또는 % 값이 필수로 들어가야합니다.\ncss - margin 과 유사한 속성으로 선언이 가능하며, 지정한 값 만큼 Viewport를 늘이거나 줄일 수 있습니다. 해당 페이지를 예로 들어보겠습니다.\noptions.rootMargin 값을 \u0026lsquo;0px\u0026rsquo; 또는 \u0026lsquo;0%\u0026lsquo;로 지정했을 때의 Viewport 영역입니다.\noptions.rootMargin 값을 \u0026lsquo;0px 0px 150px 0px\u0026rsquo; 로 지정했을 때의 Viewport 영역입니다. 보이는것처럼, 기존 Viewport의 화면보다 지정한 값 만큼 viewport가 늘어나게 됩니다.\noptions.rootMargin 값을 \u0026lsquo;0px 0px 150px -200px\u0026rsquo; 로 지정했을 때의 Viewport 영역입니다. 마찬가지로, 기존 Viewport상에서 -200px 만큼 빠진 영역이 Viewport가 됩니다.\n실전에서 예를 들어보자면, 저는 해당 기술을 사용하면서 브라우저의 가운데만을 Viewport로 삼은 후 지정한 엘리먼트가 브라우저의 가운데 영역과 완전히 겹쳤을 때 Observer 실행이 이루어지는 기능을 구현하고싶었습니다. 그러기 위해서는 Viewport의 위치를 먼저 지정해줘야했고, 가장 자연스러운 위치를 계산한 결과 나온 Viewport 의 영역은\nrootMargin: '-25% 0% -25% 0%' 해당 사진과 같은 Viewport 입니다.\n계산과 같이 Viewport의 height 값이 472px 로 잘 잡혀주었습니다.\noptions 값의 threshold 위 rootMargin에 의해 세팅된 Viewport 영역과 observe 시킨 대상 엘리먼트가 얼마나 겹쳤을때 감지가 이뤄지는지를 설정할 수 있습니다. 1을 100%로 계산하며, 1 초과, 0 미만의 수는 사용할 수 없습니다. (에러가 뜹니다!)\n[observe 대상 지정하기]에서 말했던 것 처럼, 겹침 대상 감지 엘리먼트를 아래처럼 위 상단의 타이틀 이미지라고 가정해봅시다.\n해당 엘리먼트를 아래와 같이 observe 시킵니다.\n1 observer.observe(document.querySelector(\u0026#34;.article-image\u0026#34;)); options.threshold 를 1로 지정했을때, 엘리먼트의 100% 영역이 Viewport와 겹쳐야만 API가 옵저버 실행을 성공할것입니다.\n1 2 3 4 var options = { ... threshold: 1 } 사진과 같이 엘리먼트가 100% Viewport와 겹쳤을 경우부터 옵저버가 실행됩니다. 다음으로는 0.5를 확인해보겠습니다.\n1 2 3 4 var options = { ... threshold: 0.5 } 엘리먼트가 50% Viewport와 겹치게 된 순간부터 옵저버가 실행됩니다.\n이 다음은 threshold 를 0으로 지정했을 때 입니다.\n1 2 3 4 var options = { ... threshold: 0 } 위와 같이 viewport와 지정 엘리먼트가 닿는 지점부터 옵저버가 실행됩니다.\noptions.threshold 는 이 뿐만 아니라, array 를 통해 연속 실행도 가능하도록 세팅이 가능합니다.\n1 2 3 4 var options = { ... threshold: 0 } 예를 들어 값을 [0, 0.3, 1]로 지정하였을 경우, threshold 감지 실행 기준이 0 일때, 0.3일 때, 1일 때를 기준으로 한번 씩 옵저버를 실행해줍니다.\n테스트! 해당 포스트에서 사용한 IntersectionObserver API의 예시입니다.\n콘솔창에 그대로 복붙하면 감지가 이뤄지는 기준을 확인할수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 document.querySelector(\u0026#34;.article-header\u0026#34;).style.paddingTop = \u0026#34;1000px\u0026#34;; var viewportDiv = document.createElement(\u0026#34;div\u0026#34;); viewportDiv.style.height = \u0026#34;50%\u0026#34;; viewportDiv.style.width = \u0026#34;100%\u0026#34;; viewportDiv.style.position = \u0026#34;fixed\u0026#34;; viewportDiv.style.top = \u0026#34;25%\u0026#34;; viewportDiv.style.left = \u0026#34;0\u0026#34;; viewportDiv.style.background = \u0026#34;lightgoldenrodyellow\u0026#34;; viewportDiv.style.opacity = \u0026#34;0.5\u0026#34;; viewportDiv.innerHTML = \u0026#34;가상 VIEWPORT - 동적으로 움직이지 않습니다.\u0026#34;; document.querySelector(\u0026#34;body\u0026#34;).append(viewportDiv); document.querySelector(\u0026#34;.article-header\u0026#34;).focus(); document.querySelector(\u0026#34;.article-header\u0026#34;).scrollIntoView(); var observer = new IntersectionObserver( (obs, ins) =\u0026gt; { // 설정값에 맞춰서 감지 후 실행할 때 타는 영역. console.log(\u0026#34;ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\u0026#34;); console.log(\u0026#34;감지!\u0026#34;); console.log(obs[0]); }, { //options root: null, rootMargin: \u0026#34;-25% 0% -25% 0%\u0026#34;, threshold: 0, } ); observer.observe(document.querySelector(\u0026#34;.article-image\u0026#34;)); entries IntersectionObserver 감지 실행 후 작동하는 callback을 통해 인스턴스에서 제공하는 기능들을 사용 가능합니다.\nboundingClientRect: 관찰 대상의 사각형 정보\nintersectionRect: 관찰 대상의 교차 영역 정보\nintersectionRatio: 관찰 대상의 교차한 영역 백분율\nisIntersecting: 관찰 대상의 교차 상태(Boolean)\nrootBounds: 지정한 루트 요소의 사각형 정보(DOMRectReadOnly)\ntarget: 관찰 대상 요소(Element)\ntime: 변경이 발생한 시간 정보(DOMHighResTimeStamp)\n작업을 하며 느낀 장점 ★ 브라우저가 리사이징 될 때의 값도 계산하여 Viewport 영역과 height를 함께 API 인스턴스에서 받아볼수 있음이 큰 장점. scroll 이벤트를 사용할 때에는 항상 퍼포먼스 이슈를 염두에 두고 작업해야했는데, 그보다 훨씬 가벼운 형태로 똑같은 기능을 구현할 수 있는 점이 큰 장점. 인스턴스에서 entries를 통해 정보값을 얻어오기 편함. (따로 엘리먼트를 선언해서, 그 값을 가져오지않아도 됨.) 교차가 제대로 이루어졌는지에 대해 Boolean값으로 확인 가능함. 참고문서 https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\nhttp://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial/\n","date":"2022-11-11T00:26:00Z","image":"https://blog.realsn.com/p/intersection-observer-api/thumb_hu232e2de08a6578f5ceeb8c7a53e589a1_41476_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/intersection-observer-api/","title":"Intersection Observer API"},{"content":" 기초 구성 프로젝트 생성 우선 Windows 탐색기를 이용하여 프로젝트를 생성하고자 하는 경로로 이동합니다. ex) C:\\hugo\\Sites 해당 경로에서 우클릭 후 'Git Bash Here'을 클릭하여 커맨드 창을 실행합니다. 커맨드 창에서 'hugo new site [project_name]'을 입력 후 실행합니다. ex) hugo new site blog.realsn.com C:\\hugo\\Sites\\[project_name] 폴더가 생성되었다면 성공적으로 생성된 것 입니다. * ex) C:\\hugo\\Sites\\blog.realsn.com config.toml 수정 기존 내용 수정 (프로젝트 생성 시 기본적으로 선언되는 옵션 수정)\nbaseURL에 내가 만들 리소스가 배포 될 url을 입력하세요. ex)baseURL = 'https://blog.realsn.com/ title에 내가 만들 리소스의 타이틀을 지정하여 주세요. * ex)title = 'RSN UX_Lab Blog' 추가 내용 작성 (기본으로 선언되는 옵션 하단에 기재하는 추가 옵션) 1. disableKinds = ['taxonomy', 'term', 'RSS', 'sitemap']을 작성합니다. _ 기본으로 build시 생성되는 파일 중에서 Publishing Resource에 해당하지 않는 내용들을 제거합니다. 2. [outputFormats]옵션을 작성합니다. _ Hugo Build 시 산출물이 저장되는 경로를 설정합니다. * default = '/' -\u0026gt; [project_path]/public\n/layouts 구성 _defalut 구성\nbaseof.html 기본 뼈대가 되는 layout을 구성합니다. partial을 통해서 Header, Footer 등 공통 리소스를 가져와 구성합니다. list.html Build시 오류를 방지하기 위해 작성하는 파일이므로 사용하지는 않습니다. single.html [project_path]/content하위의 파일 중 front matter가 존재하는 파일의 컨텐츠가 삽입되어지는 파일 입니다. partials 구성\ninclude 될 모든 파일 shortcodes 구성 * partial.html\n/assets 구성 /js\nWebpack으로 bundling 할 resource 중 *.js파일을 저장합니다. /scss _ Webpack으로 bundling 할 resource 중 _.scss파일을 저장합니다.\n본래 용도는 JS, CSS, img등의 Resource를 저장하고 불러올 때 사용하지만 우리는 Publishing을 위한 파일을 저장합니다.\n/static 구성 /fonts\nicomoon등 font 설정 파일 중 동적 리소스만을 저장합니다. /img\nlogo등의 image파일을 저장합니다. /js\n*.js파일 중 동적 리소스를 저장하며, Webpack으로 Bundling된 resource도 이곳에 저장합니다. 형상관리 최초 project set-up시 개발리소스와 배포리소스 분리 hugo build 후 public 폴더를 먼저 배포리소스 git에 push 작업Directory에서 public 폴더 삭제 후 개발리소스 git에 push 이후에 개발리소스에서 배포리소스를 submodule로 등록 작업시작 최초 set-up 이후 git clone으로 프로젝트 내려 받은 뒤 형상 관리 개발리소스를 원하는 경로에 git clone 개발리소스 경로에서 git command를 이용하여 submodule 정보 update git submodule init git submodule update cd public git checkout main 작업시작 ","date":"2022-10-19T22:47:00Z","image":"https://blog.realsn.com/p/hugo-framework%EB%A1%9C-publishing-%ED%95%98%EA%B8%B0/thumb_hu7a40aff17dad05f5d5a0240715286247_245554_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/hugo-framework%EB%A1%9C-publishing-%ED%95%98%EA%B8%B0/","title":"Hugo Framework로 Publishing 하기"},{"content":"Hugo 공식문서의 설치법 링크에 접속하면 공식 문서의 다양한 설치법이 기재되어 있습니다.\n하지만 패키지 관리자를 설치하는 과정, CLI를 이용하는 등의 과정이 번거로워 Windows환경에서 직접 설치하는 법을 기재합니다 Windows에서 패키지 관리자 없이 설치하는 법 링크에 접속하면 빌드 되어있는 휴고의 release를 확인할 수 있습니다. 해당 페이지에서 원하는 버전에 해당하는 Release를 찾습니다.\n본 게시글을 작성하는 시점의 최신버전 : v0.104.1\n본 게시글을 빌드한 버전 : v0.103.1 하단에 Assets 메뉴를 클릭하여 펼친 후 \u0026lsquo;Show all nn assets\u0026rsquo;를 클릭합니다.\n0.104.1버전의 경우 'Show all 23 assets' \u0026lsquo;hugo_extended_version_windows-amd64.zip\u0026rsquo;을 클릭하여 다운 받습니다. 다운받은 압축파일의 압축을 풀고 \u0026lsquo;hugo.exe\u0026rsquo; 파일을 경로(C:\\Hugo\\bin)에 넣습니다.\nHugo Document에서는 'C:\\Hugo\\bin'을 기본 경로로 설명하고 있기에 본 설명은 해당 경로에 설치합니다 링크를 참조하여 환경 변수 편집에 들어갑니다. 환경 변수에 C:\\Hugo\\bin경로를 추가하면 설치가 모두 완료되었습니다.\n본 글에서 설명한 경로가 아닌 다른 경로에 'hugo.exe'를 넣었다면 해당하는 경로를 입력해주세요 올바르게 설치되었는지 확인하는 법 명령프롬프트(CMD)를 실행해줍니다. hugo version 명령어를 실행한 뒤 아래와 같이 나타나는지 확인합니다. 아래의 사진이 잘 보이지 않는다면 우클릭 후 '새 탭에서 이미지 열기'로 연 뒤 보는것을 권장합니다 위의 사진 처럼 휴고의 버전이 나오지 않는다면 설치가 되지 않은 것이므로 처음부터 다시 해보는 것을 권장합니다. ","date":"2022-09-29T09:48:00Z","image":"https://blog.realsn.com/p/hugo-framework-%EC%84%A4%EC%B9%98/thumb_hu7a40aff17dad05f5d5a0240715286247_238394_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/hugo-framework-%EC%84%A4%EC%B9%98/","title":"Hugo Framework 설치"},{"content":"\nHugo Framework를 선택한 이유에 대하여 간단하게 정리하여 작성하겠습니다.\n목차 Client Side와 Server Side에 대한 간략한 설명 Web Server와 Web Application Server에 대한 간략한 설명 그래서 왜 Hugo Framework를 선택하게 되었는지? 예시페이지를 JSP와 Hugo로 작성했을때의 샘플 코드 예시페이지의 실행 결과 Hugo Framework의 Directory 구조와 반자동 배포에 대하여 정의 Client Side는 클라이언트(사용자)환경에서 처리되는 것이라고 할 수 있습니다. HTML, CSS, JavaScript 등을 예로 들 수 있습니다. Server Side는 서버환경에서 처리하는 것이라고 할 수 있습니다. 대표적으로 JSP, ASP.Net, PHP 등 프로그래밍 언어로 만들어진 파일들을 예로 들 수 있습니다. 처리과정 Client Side는 사용자가 HTTP요청에 따라 파일을 전달받아 그 파일 내의 코드를 웹브라우저가 직접 해석하고 화면을 렌더링하여 사용자에게 보여줍니다. Server Side는 서버의 WAS에서 코드를 해석한 뒤 HTML 형식으로 빌드하여 사용자에게 넘겨주는 과정이 추가됩니다. 배포과정 Cleint Side는 정적페이지로 이루어져 있고 그 내용은 사용자의 웹브라우저가 해석이 가능하므로 단순한 Web Server만으로도 배포가 가능합니다. Server Side는 동적페이지로 이루어져 있고 사용자의 웹브라우저에서 단독으로 해석이 불가능하기 때문에 WAS를 이용한 배포만 가능합니다. 정의 Web Server는 사용자로부터 HTTP요청을 수신한 뒤 경로에 해당하는 정적 리소스를 반환합니다. 대표적으로 Apache Server, GitHub Pages 등이 있습니다. Web Apllication Server는 Web Server의 기능에 동적 리소스를 정적 리소스로 변환하여 사용자에게 반환할 수 있습니다. 대표적으로 Apache Tomcat, NginX 등이 있습니다. 목적 Web Server는 서버 측에 저장된 파일 중에서 HTML, CSS, JS, 이미지 등 상태가 변하지 않는 정적 리소스만을 사용자에게 반환할 수 있습니다. Web Apllication Server는 Server Side언어로 만들어진 동적 리소스들을 정적 리소스로 변환하여 전달할 수 있습니다. 처리 환경 Web Server는 정적 리소스만을 취급하기 때문에 로컬 환경에서 테스트를 진행할 때에는 굳이 Web Server를 동작시킬 필요 없이 웹브라우저에서 단독으로 테스트가 가능합니다. Web Apllication Server는 동적 리소스를 취급할 때에 있어서 필수적인 요소로 작용하기 때문에 동적 리소스를 취급함에 있어서 WAS는 필수적으로 동작되어야 합니다. Client Side로 이루어져 있습니다.\nHugo의 빌드 결과물은 정적 리소스로 이루어져 있어 WAS를 사용하지 않고 로컬 환경에서 손쉽게 테스트가 가능하며 Web Server만을 이용하여 간편하게 배포가 가능합니다. SASS 통합 컴파일, JavaScript 번들링을 지원합니다.\nHugo는 자체적으로 SASS 컴파일과 JavaScript 번들링하여 빌드할 수 있습니다. 기존에 SASS를 작성하여 컴파일하고, JavaScript를 번들링한 뒤 WAS를 통하여 리소스를 배포하였다면, Hugo를 사용할 때에는 설정만 해둔다면 Hugo명령어를 통하여 한 번에 처리가 가능합니다. 정적 리소스임에도 불구하고 Layout을 구성해두면 지속적으로 재사용이 가능합니다.\nHugo는 header, footer등 미리 만들어둔 파일을 partial을 통하여 불러와서 사용할 수 있습니다. 기존에는 include 기능을 사용하기 위하여 jsp를 이용하여 산출물을 만들었고 그렇기 때문에 WAS를 이용하여야만 했습니다. Git을 활용하면 형상관리와 배포를 동시에 처리할 수 있습니다.\nHugo는 Git을 이용한다면 아주 간편하게 공유 및 배포가 가능합니다. 기존에는 WAS를 통해서만 산출물을 배포할 수 있었지만 Hugo는 Git의 Submodule 기능을 활용한다면 소스코드와 산출물을 분리하여 관리, 배포할 수 있고 이 과정을 스크립트를 통해 '반 자동화'하여 편리하게 이용할 수 있습니다. 종합 - 기존 산출물을 테스트하기 위해서는 JDK, Apache Tomcat을 설치하여야 했고, Apache Tomcat을 실행시켜둬야함 SASS 컴파일, JavaScript 번들링 등의 과정을 별도로 거쳤어야함 종합 - Hugo 산출물을 로컬에서 테스트 할 때에는 Hugo가 설치된 상태로 hugo server명령어만 입력하면 실시간으로 테스트 가능 SASS 컴파일, JavaScript 번들링 또한 Hugo 빌드 시 자체적으로 처리(extended 버전 한정) JSP 샘플코드\n페이지 최상단에 jsp 선언을 합니다. html 구조를 작성합니다. 삽입되어질 페이지를 include 합니다. 각 페이지에 맞는 컨텐츠를 작성합니다. Hugo 샘플코드\nbaseof.html에 기본적인 html구조 및 partial을 작성합니다. single.html에 컨텐츠 영역을 설정합니다. index.html에 Front Matter(--- ---)를 작성한 뒤 컨텐츠를 작성합니다. 차이점\nJSP의 경우에는 페이지가 늘어나면 각 페이지마다 상기 1~4번의 과정을 계속해서 거쳐야 합니다. Hugo의 경우에는 3번의 과정인 Front Matter를 작성하고 컨텐츠를 작성하면 1~2번에 작성한 내용이 자동으로 재사용 됩니다. 위 화면은 상기 샘플코드를 실행했을 때의 결과이며, 2개의 코드 모두 결과는 동일합니다.\nHugo Site의 폴더구조 및 반자동 배포\n좌측은 Hugo Framework을 이용하여 만든 Site의 기본적인 Directory Structure이며 링크에서 더 자세히 알아볼 수 있습니다.\n우측은 쉘 스크립트를 이용하여 커밋메시지만 입력하면 Hugo로 만들어진 사이트를 빌드하고 결과물과 소스코드를 각각 git에 push하는 반 자동화 배포 스크립트 입니다.\n","date":"2022-09-28T10:25:00Z","image":"https://blog.realsn.com/p/hugo-framework%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/thumb_hu7a40aff17dad05f5d5a0240715286247_240140_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/hugo-framework%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/","title":"Hugo Framework를 선택하게 된 이유"}]
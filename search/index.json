[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 { \u0026#34;\u0026#34;: [ \u0026#34;--------------------------------------------------------------------------------------------\u0026#34;, \u0026#34;Copyright (c) Microsoft Corporation. All rights reserved.\u0026#34;, \u0026#34;Licensed under the MIT License. See License.txt in the project root for license information.\u0026#34;, \u0026#34;--------------------------------------------------------------------------------------------\u0026#34;, \u0026#34;Do not edit this file. It is machine generated.\u0026#34; ], \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;contents\u0026#34;: { \u0026#34;package\u0026#34;: { \u0026#34;displayName\u0026#34;: \u0026#34;Git\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Git SCM 통합\u0026#34;, \u0026#34;command.setLogLevel\u0026#34;: \u0026#34;로그 수준 설정...\u0026#34;, \u0026#34;command.clone\u0026#34;: \u0026#34;복제\u0026#34;, \u0026#34;command.cloneRecursive\u0026#34;: \u0026#34;복제(재귀)\u0026#34;, \u0026#34;command.init\u0026#34;: \u0026#34;리포지토리 초기화\u0026#34;, \u0026#34;command.openRepository\u0026#34;: \u0026#34;리포지토리 열기\u0026#34;, \u0026#34;command.close\u0026#34;: \u0026#34;리포지토리 닫기\u0026#34;, \u0026#34;command.refresh\u0026#34;: \u0026#34;새로 고침\u0026#34;, \u0026#34;command.openChange\u0026#34;: \u0026#34;변경 내용 열기\u0026#34;, \u0026#34;command.openFile\u0026#34;: \u0026#34;파일 열기\u0026#34;, \u0026#34;command.openHEADFile\u0026#34;: \u0026#34;파일 열기(HEAD)\u0026#34;, \u0026#34;command.stage\u0026#34;: \u0026#34;변경 내용 스테이징\u0026#34;, \u0026#34;command.stageAll\u0026#34;: \u0026#34;모든 변경 내용 스테이징\u0026#34;, \u0026#34;command.stageAllTracked\u0026#34;: \u0026#34;추적된 모든 변경 내용 스테이징\u0026#34;, \u0026#34;command.stageAllUntracked\u0026#34;: \u0026#34;추적되지 않은 모든 변경 내용 스테이징\u0026#34;, \u0026#34;command.stageAllMerge\u0026#34;: \u0026#34;모든 병합 변경 내용 스테이징\u0026#34;, \u0026#34;command.stageSelectedRanges\u0026#34;: \u0026#34;선택한 범위 스테이징\u0026#34;, \u0026#34;command.revertSelectedRanges\u0026#34;: \u0026#34;선택한 범위 되돌리기\u0026#34;, \u0026#34;command.stageChange\u0026#34;: \u0026#34;변경 내용 스테이징\u0026#34;, \u0026#34;command.revertChange\u0026#34;: \u0026#34;변경 내용 되돌리기\u0026#34;, \u0026#34;command.unstage\u0026#34;: \u0026#34;변경 내용 스테이징 취소\u0026#34;, \u0026#34;command.unstageAll\u0026#34;: \u0026#34;모든 변경 내용 스테이징 취소\u0026#34;, \u0026#34;command.unstageSelectedRanges\u0026#34;: \u0026#34;선택한 범위 스테이징 취소\u0026#34;, \u0026#34;command.clean\u0026#34;: \u0026#34;변경 내용 취소\u0026#34;, \u0026#34;command.cleanAll\u0026#34;: \u0026#34;모든 변경 내용 취소\u0026#34;, \u0026#34;command.cleanAllTracked\u0026#34;: \u0026#34;추적된 모든 변경 내용 취소\u0026#34;, \u0026#34;command.cleanAllUntracked\u0026#34;: \u0026#34;추적되지 않은 모든 변경 내용 취소\u0026#34;, \u0026#34;command.commit\u0026#34;: \u0026#34;커밋\u0026#34;, \u0026#34;command.commitStaged\u0026#34;: \u0026#34;스테이징된 항목 커밋\u0026#34;, \u0026#34;command.commitEmpty\u0026#34;: \u0026#34;빈 내용을 커밋합니다.\u0026#34;, \u0026#34;command.commitStagedSigned\u0026#34;: \u0026#34;스테이징된 항목 커밋(로그오프됨)\u0026#34;, \u0026#34;command.commitStagedAmend\u0026#34;: \u0026#34;스테이징된 항목 커밋(수정)\u0026#34;, \u0026#34;command.commitAll\u0026#34;: \u0026#34;모두 커밋\u0026#34;, \u0026#34;command.commitAllSigned\u0026#34;: \u0026#34;모두 커밋(로그오프됨)\u0026#34;, \u0026#34;command.commitAllAmend\u0026#34;: \u0026#34;모두 커밋 (수정)\u0026#34;, \u0026#34;command.commitNoVerify\u0026#34;: \u0026#34;커밋(확인 안 함)\u0026#34;, \u0026#34;command.commitStagedNoVerify\u0026#34;: \u0026#34;커밋 스테이징됨(확인 안 함)\u0026#34;, \u0026#34;command.commitEmptyNoVerify\u0026#34;: \u0026#34;빈 상태로 커밋(확인 안 함)\u0026#34;, \u0026#34;command.commitStagedSignedNoVerify\u0026#34;: \u0026#34;커밋 스테이징됨(로그오프됨, 확인 안 함)\u0026#34;, \u0026#34;command.commitStagedAmendNoVerify\u0026#34;: \u0026#34;커밋 스테이징됨(수정, 확인 안 함)\u0026#34;, \u0026#34;command.commitAllNoVerify\u0026#34;: \u0026#34;모두 커밋(확인 안 함)\u0026#34;, \u0026#34;command.commitAllSignedNoVerify\u0026#34;: \u0026#34;모두 커밋(로그오프됨, 확인 안 함)\u0026#34;, \u0026#34;command.commitAllAmendNoVerify\u0026#34;: \u0026#34;모두 커밋(수정, 확인 안 함)\u0026#34;, \u0026#34;command.restoreCommitTemplate\u0026#34;: \u0026#34;커밋 템플릿 복원\u0026#34;, \u0026#34;command.undoCommit\u0026#34;: \u0026#34;마지막 커밋 실행 취소\u0026#34;, \u0026#34;command.checkout\u0026#34;: \u0026#34;다음으로 체크 아웃...\u0026#34;, \u0026#34;command.branch\u0026#34;: \u0026#34;분기 만들기...\u0026#34;, \u0026#34;command.branchFrom\u0026#34;: \u0026#34;분기를 만듭니다...\u0026#34;, \u0026#34;command.deleteBranch\u0026#34;: \u0026#34;분기 삭제...\u0026#34;, \u0026#34;command.renameBranch\u0026#34;: \u0026#34;분기 이름 바꾸기...\u0026#34;, \u0026#34;command.merge\u0026#34;: \u0026#34;분기 병합...\u0026#34;, \u0026#34;command.rebase\u0026#34;: \u0026#34;분기 다시 지정...\u0026#34;, \u0026#34;command.createTag\u0026#34;: \u0026#34;태그 만들기\u0026#34;, \u0026#34;command.deleteTag\u0026#34;: \u0026#34;태그 삭제\u0026#34;, \u0026#34;command.fetch\u0026#34;: \u0026#34;페치\u0026#34;, \u0026#34;command.fetchPrune\u0026#34;: \u0026#34;페치(정리)\u0026#34;, \u0026#34;command.fetchAll\u0026#34;: \u0026#34;모든 원격에서 페치\u0026#34;, \u0026#34;command.pull\u0026#34;: \u0026#34;풀\u0026#34;, \u0026#34;command.pullRebase\u0026#34;: \u0026#34;풀(다시 지정)\u0026#34;, \u0026#34;command.pullFrom\u0026#34;: \u0026#34;가져올 위치...\u0026#34;, \u0026#34;command.push\u0026#34;: \u0026#34;푸시\u0026#34;, \u0026#34;command.pushForce\u0026#34;: \u0026#34;푸시(강제)\u0026#34;, \u0026#34;command.pushTo\u0026#34;: \u0026#34;다음으로 푸시...\u0026#34;, \u0026#34;command.pushToForce\u0026#34;: \u0026#34;...로 푸시 (강제)\u0026#34;, \u0026#34;command.pushFollowTags\u0026#34;: \u0026#34;푸시(태그 팔로우)\u0026#34;, \u0026#34;command.pushFollowTagsForce\u0026#34;: \u0026#34;푸시(태그 팔로우, 강제 적용)\u0026#34;, \u0026#34;command.addRemote\u0026#34;: \u0026#34;원격 추가...\u0026#34;, \u0026#34;command.removeRemote\u0026#34;: \u0026#34;원격 제거\u0026#34;, \u0026#34;command.sync\u0026#34;: \u0026#34;동기화\u0026#34;, \u0026#34;command.syncRebase\u0026#34;: \u0026#34;동기화(다시 지정)\u0026#34;, \u0026#34;command.publish\u0026#34;: \u0026#34;분기 게시...\u0026#34;, \u0026#34;command.showOutput\u0026#34;: \u0026#34;Git 출력 표시\u0026#34;, \u0026#34;command.ignore\u0026#34;: \u0026#34;.gitignore에 추가\u0026#34;, \u0026#34;command.revealInExplorer\u0026#34;: \u0026#34;사이드바에 표시\u0026#34;, \u0026#34;command.rebaseAbort\u0026#34;: \u0026#34;다시 지정 중단\u0026#34;, \u0026#34;command.stashIncludeUntracked\u0026#34;: \u0026#34;스태시(미추적 포함)\u0026#34;, \u0026#34;command.stash\u0026#34;: \u0026#34;스태시\u0026#34;, \u0026#34;command.stashPop\u0026#34;: \u0026#34;스태시 표시...\u0026#34;, \u0026#34;command.stashPopLatest\u0026#34;: \u0026#34;최신 슬래시 표시\u0026#34;, \u0026#34;command.stashApply\u0026#34;: \u0026#34;스태시 적용하기\u0026#34;, \u0026#34;command.stashApplyLatest\u0026#34;: \u0026#34;최신 스태시 적용하기\u0026#34;, \u0026#34;command.stashDrop\u0026#34;: \u0026#34;스태시 삭제...\u0026#34;, \u0026#34;command.timelineOpenDiff\u0026#34;: \u0026#34;변경 내용 열기\u0026#34;, \u0026#34;command.timelineCopyCommitId\u0026#34;: \u0026#34;커밋 ID 복사\u0026#34;, \u0026#34;command.timelineCopyCommitMessage\u0026#34;: \u0026#34;커밋 메시지 복사\u0026#34;, \u0026#34;config.enabled\u0026#34;: \u0026#34;Git을 사용하도록 설정했는지 여부입니다.\u0026#34;, \u0026#34;config.path\u0026#34;: \u0026#34;git 실행 파일의 경로 및 파일 이름입니다(예: `C:\\\\Program Files\\\\Git\\\\bin\\\\git.exe`(Windows)). 조회할 여러 경로를 포함하는 문자열 값의 배열일 수도 있습니다.\u0026#34;, \u0026#34;config.autoRepositoryDetection\u0026#34;: \u0026#34;리포지토리가 자동으로 감지되어야 하는 경우를 구성합니다.\u0026#34;, \u0026#34;config.autoRepositoryDetection.true\u0026#34;: \u0026#34;현재 열려 있는 폴더의 하위 폴더와 열려 있는 파일의 부모 폴더를 모두 검사합니다.\u0026#34;, \u0026#34;config.autoRepositoryDetection.false\u0026#34;: \u0026#34;자동 리포지토리 검사를 사용하지 않습니다.\u0026#34;, \u0026#34;config.autoRepositoryDetection.subFolders\u0026#34;: \u0026#34;현재 열려 있는 폴더의 하위 폴더를 검사합니다.\u0026#34;, \u0026#34;config.autoRepositoryDetection.openEditors\u0026#34;: \u0026#34;열려 있는 파일의 부모 폴더를 검사합니다.\u0026#34;, \u0026#34;config.autorefresh\u0026#34;: \u0026#34;자동 새로 고침을 사용할지 여부입니다.\u0026#34;, \u0026#34;config.autofetch\u0026#34;: \u0026#34;사용하도록 설정하는 경우 현재 Git 리포지토리의 기본 원격에서 커밋을 자동으로 가져옵니다.\u0026#34;, \u0026#34;config.autofetchPeriod\u0026#34;: \u0026#34;`git.autofetch`가 사용되는 경우 각 자동 git fetch 사이의 시간(초)입니다.\u0026#34;, \u0026#34;config.confirmSync\u0026#34;: \u0026#34;Git 리포지토리를 동기화하기 전에 확인합니다.\u0026#34;, \u0026#34;config.countBadge\u0026#34;: \u0026#34;Git 개수 배지를 제어합니다.\u0026#34;, \u0026#34;config.countBadge.all\u0026#34;: \u0026#34;모든 변경 내용을 계산합니다.\u0026#34;, \u0026#34;config.countBadge.tracked\u0026#34;: \u0026#34;추적된 변경 내용만 계산합니다.\u0026#34;, \u0026#34;config.countBadge.off\u0026#34;: \u0026#34;카운터를 끕니다.\u0026#34;, \u0026#34;config.checkoutType\u0026#34;: \u0026#34;\u0026#39;다음으로 체크 아웃...\u0026#39;을 실행할 때 나열되는 분기 유형을 제어합니다.\u0026#34;, \u0026#34;config.checkoutType.all\u0026#34;: \u0026#34;모든 참조를 표시합니다.\u0026#34;, \u0026#34;config.checkoutType.local\u0026#34;: \u0026#34;로컬 분기만 표시합니다.\u0026#34;, \u0026#34;config.checkoutType.tags\u0026#34;: \u0026#34;태그만 표시합니다.\u0026#34;, \u0026#34;config.checkoutType.remote\u0026#34;: \u0026#34;원격 분기만 표시합니다.\u0026#34;, \u0026#34;config.branchValidationRegex\u0026#34;: \u0026#34;새 분기 이름의 유효성을 검사하는 정규식입니다.\u0026#34;, \u0026#34;config.branchWhitespaceChar\u0026#34;: \u0026#34;새 브랜치 이름에서 공백을 대체하는 문자.\u0026#34;, \u0026#34;config.ignoreLegacyWarning\u0026#34;: \u0026#34;레거시 Git 경고를 무시합니다.\u0026#34;, \u0026#34;config.ignoreMissingGitWarning\u0026#34;: \u0026#34;Git이 없으면 경고를 무시합니다.\u0026#34;, \u0026#34;config.ignoreWindowsGit27Warning\u0026#34;: \u0026#34;Windows에 Git 2.25~2.26이 설치되어 있는 경우 경고를 무시합니다.\u0026#34;, \u0026#34;config.ignoreLimitWarning\u0026#34;: \u0026#34;리포지토리에 변경 내용이 너무 많으면 경고를 무시합니다.\u0026#34;, \u0026#34;config.defaultCloneDirectory\u0026#34;: \u0026#34;Git 리포지토리를 복제할 기본 위치입니다.\u0026#34;, \u0026#34;config.enableSmartCommit\u0026#34;: \u0026#34;단계적 변경 사항이 없는 경우 모든 변경 사항을 저장합니다.\u0026#34;, \u0026#34;config.smartCommitChanges\u0026#34;: \u0026#34;스마트 커밋에서 자동으로 스테이징되는 변경 사항을 제어합니다.\u0026#34;, \u0026#34;config.smartCommitChanges.all\u0026#34;: \u0026#34;모든 변경 사항을 자동으로 스테이징합니다.\u0026#34;, \u0026#34;config.smartCommitChanges.tracked\u0026#34;: \u0026#34;추적된 변경 사항만 자동으로 스테이징했습니다.\u0026#34;, \u0026#34;config.suggestSmartCommit\u0026#34;: \u0026#34;스마트 커밋을 사용하도록 제안합니다(스테이징된 변경 사항이 없는 경우 모든 변경 사항 커밋).\u0026#34;, \u0026#34;config.enableCommitSigning\u0026#34;: \u0026#34;GPG 또는 X.509로 서명 커밋을 사용합니다.\u0026#34;, \u0026#34;config.discardAllScope\u0026#34;: \u0026#34;`모든 변경 내용 취소` 명령으로 취소되는 변경 내용을 제어합니다. `all`이면 모든 변경 내용을 취소합니다. `tracked`이면 추적된 파일만 취소합니다. `prompt`이면 작업을 실행할 때마다 프롬프트 대화 상자를 표시합니다.\u0026#34;, \u0026#34;config.decorations.enabled\u0026#34;: \u0026#34;Git에서 색과 배지를 탐색기와 열려 있는 편집기 뷰에 적용하는지 여부를 제어합니다.\u0026#34;, \u0026#34;config.enableStatusBarSync\u0026#34;: \u0026#34;Git Sync 명령이 상태 표시줄에 표시되는지 여부를 제어합니다.\u0026#34;, \u0026#34;config.promptToSaveFilesBeforeCommit\u0026#34;: \u0026#34;Git가 제출(commit)하기 전에 저장되지 않은 파일을 검사할지를 제어합니다. \u0026#34;, \u0026#34;config.promptToSaveFilesBeforeCommit.always\u0026#34;: \u0026#34;저장되지 않은 파일이 있는지 확인합니다.\u0026#34;, \u0026#34;config.promptToSaveFilesBeforeCommit.staged\u0026#34;: \u0026#34;저장되지 않은 스테이징된 파일만 확인합니다.\u0026#34;, \u0026#34;config.promptToSaveFilesBeforeCommit.never\u0026#34;: \u0026#34;이 검사를 사용하지 않도록 설정합니다.\u0026#34;, \u0026#34;config.postCommitCommand\u0026#34;: \u0026#34;커밋 후 git 명령을 실행합니다.\u0026#34;, \u0026#34;config.postCommitCommand.none\u0026#34;: \u0026#34;커밋 후 명령을 실행하지 않습니다.\u0026#34;, \u0026#34;config.postCommitCommand.push\u0026#34;: \u0026#34;성공적인 커밋 후 \u0026#39;Git Push\u0026#39;를 실행합니다.\u0026#34;, \u0026#34;config.postCommitCommand.sync\u0026#34;: \u0026#34;성공적인 커밋 후 \u0026#39;Git Sync\u0026#39;를 실행합니다.\u0026#34;, \u0026#34;config.showInlineOpenFileAction\u0026#34;: \u0026#34;Git 변경점 보기에서 파일 열기 동작 줄을 표시할지의 여부를 제어합니다.\u0026#34;, \u0026#34;config.showPushSuccessNotification\u0026#34;: \u0026#34;푸시가 성공했을 때 알림을 표시할지 여부를 제어합니다.\u0026#34;, \u0026#34;config.inputValidation\u0026#34;: \u0026#34;커밋 메시지 입력 유효성 검사를 언제 표시할지 제어합니다.\u0026#34;, \u0026#34;config.inputValidationLength\u0026#34;: \u0026#34;경고 표시를 위한 커밋 메시지 길이 임계값을 제어합니다.\u0026#34;, \u0026#34;config.inputValidationSubjectLength\u0026#34;: \u0026#34;경고 표시를 위한 커밋 메시지 제목 길이 임계값을 제어합니다. `config.inputValidationLength` 값을 상속하려면 이 임계값 설정을 해제하세요.\u0026#34;, \u0026#34;config.detectSubmodules\u0026#34;: \u0026#34;Git 하위 모듈을 자동으로 검색할지 여부를 제어합니다.\u0026#34;, \u0026#34;config.detectSubmodulesLimit\u0026#34;: \u0026#34;Git submodules 검출 개수의 제한을 제어합니다.\u0026#34;, \u0026#34;config.alwaysShowStagedChangesResourceGroup\u0026#34;: \u0026#34;스테이징된 변경 내용 리소스 그룹을 항상 표시합니다.\u0026#34;, \u0026#34;config.alwaysSignOff\u0026#34;: \u0026#34;모든 커밋에 대한 확인 플래그를 제어합니다.\u0026#34;, \u0026#34;config.ignoredRepositories\u0026#34;: \u0026#34;무시할 Git 리포지토리의 목록입니다.\u0026#34;, \u0026#34;config.scanRepositories\u0026#34;: \u0026#34;Git 리포지토리를 검색할 경로의 목록입니다.\u0026#34;, \u0026#34;config.showProgress\u0026#34;: \u0026#34;Git 작업에서 진행률을 표시할지 여부를 제어합니다.\u0026#34;, \u0026#34;config.rebaseWhenSync\u0026#34;: \u0026#34;동기화 명령을 실행할 때 Git에서 다시 지정을 사용하게 합니다.\u0026#34;, \u0026#34;config.confirmEmptyCommits\u0026#34;: \u0026#34;\u0026#39;Git: Commit Empty\u0026#39; 명령에 대한 빈 항목 생성 커밋을 항상 확인합니다.\u0026#34;, \u0026#34;config.fetchOnPull\u0026#34;: \u0026#34;사용하도록 설정하면 풀할 때 모든 분기를 페치합니다. 그렇지 않으면 현재 분기만 페치합니다.\u0026#34;, \u0026#34;config.pullTags\u0026#34;: \u0026#34;풀할 때 모든 태그를 페치합니다.\u0026#34;, \u0026#34;config.autoStash\u0026#34;: \u0026#34;풀하기 전에 변경 내용을 스태시하고 풀하는 데 성공한 후 변경 내용을 복원합니다.\u0026#34;, \u0026#34;config.allowForcePush\u0026#34;: \u0026#34;강제 푸시(임대 사용 또는 사용 안 함)가 가능한지 여부를 제어합니다.\u0026#34;, \u0026#34;config.useForcePushWithLease\u0026#34;: \u0026#34;강제 푸시가 좀 더 안전한 force-with-lease 변형을 사용하는지 여부를 제어합니다.\u0026#34;, \u0026#34;config.confirmForcePush\u0026#34;: \u0026#34;강제 푸시하기 전에 확인을 요청할지 여부를 제어합니다.\u0026#34;, \u0026#34;config.allowNoVerifyCommit\u0026#34;: \u0026#34;pre-commit 및 commit-msg 후크를 실행하지 않는 커밋이 허용되는지를 제어합니다.\u0026#34;, \u0026#34;config.confirmNoVerifyCommit\u0026#34;: \u0026#34;확인하지 않고 커밋하기 전에 확인을 요청할지를 제어합니다.\u0026#34;, \u0026#34;config.openDiffOnClick\u0026#34;: \u0026#34;변경을 클릭할 때 Diff 편집기가 열릴지 여부를 제어합니다. 그렇지 않으면 일반 편집기가 열립니다.\u0026#34;, \u0026#34;config.supportCancellation\u0026#34;: \u0026#34;동기화 작업을 실행할 때 사용자가 작업을 취소할 수 있도록 알림이 표시되는지 여부를 제어합니다.\u0026#34;, \u0026#34;config.branchSortOrder\u0026#34;: \u0026#34;분기의 정렬 순서를 제어합니다.\u0026#34;, \u0026#34;config.untrackedChanges\u0026#34;: \u0026#34;추적되지 않은 변경 내용의 작동 방식을 제어합니다.\u0026#34;, \u0026#34;config.untrackedChanges.mixed\u0026#34;: \u0026#34;추적 및 추적되지 않은 모든 변경 내용이 함께 표시되고 동일한 작업이 수행됩니다.\u0026#34;, \u0026#34;config.untrackedChanges.separate\u0026#34;: \u0026#34;추적되지 않은 변경 내용은 소스 제어 보기에 별도로 표시됩니다. 또한 여러 작업에서 제외됩니다.\u0026#34;, \u0026#34;config.untrackedChanges.hidden\u0026#34;: \u0026#34;추적되지 않은 변경 내용이 숨겨지고 여러 작업에서 제외됩니다.\u0026#34;, \u0026#34;config.showCommitInput\u0026#34;: \u0026#34;Git 소스 제어판에 커밋 입력을 표시할지 여부를 제어합니다.\u0026#34;, \u0026#34;config.terminalAuthentication\u0026#34;: \u0026#34;통합 터미널에서 생성된 git 프로세스의 인증 처리기로 VS Code를 사용할지 여부를 제어합니다. 참고: 이 설정의 변경 내용을 적용하려면 터미널을 다시 시작해야 합니다.\u0026#34;, \u0026#34;config.timeline.showAuthor\u0026#34;: \u0026#34;타임라인 보기에 커밋 작성자를 표시할지를 제어합니다.\u0026#34;, \u0026#34;config.timeline.date\u0026#34;: \u0026#34;타임라인 보기에서 항목에 사용할 날짜를 제어합니다.\u0026#34;, \u0026#34;config.timeline.date.committed\u0026#34;: \u0026#34;커밋된 날짜 사용\u0026#34;, \u0026#34;config.timeline.date.authored\u0026#34;: \u0026#34;작성 날짜 사용\u0026#34;, \u0026#34;submenu.commit\u0026#34;: \u0026#34;커밋\u0026#34;, \u0026#34;submenu.commit.amend\u0026#34;: \u0026#34;수정\u0026#34;, \u0026#34;submenu.commit.signoff\u0026#34;: \u0026#34;승인\u0026#34;, \u0026#34;submenu.changes\u0026#34;: \u0026#34;변경 사항\u0026#34;, \u0026#34;submenu.pullpush\u0026#34;: \u0026#34;풀, 푸시\u0026#34;, \u0026#34;submenu.branch\u0026#34;: \u0026#34;분기\u0026#34;, \u0026#34;submenu.remotes\u0026#34;: \u0026#34;원격\u0026#34;, \u0026#34;submenu.stash\u0026#34;: \u0026#34;스태시\u0026#34;, \u0026#34;submenu.tags\u0026#34;: \u0026#34;태그\u0026#34;, \u0026#34;colors.added\u0026#34;: \u0026#34;추가된 리소스의 색입니다.\u0026#34;, \u0026#34;colors.modified\u0026#34;: \u0026#34;수정된 리소스의 색상입니다.\u0026#34;, \u0026#34;colors.stageModified\u0026#34;: \u0026#34;스테이징되어 있는 수정된 리소스의 색입니다.\u0026#34;, \u0026#34;colors.stageDeleted\u0026#34;: \u0026#34;스테이징되어 있는 삭제된 리소스의 색입니다.\u0026#34;, \u0026#34;colors.deleted\u0026#34;: \u0026#34;삭제된 리소스의 색상입니다.\u0026#34;, \u0026#34;colors.untracked\u0026#34;: \u0026#34;추적되지 않은 리소스의 색상입니다.\u0026#34;, \u0026#34;colors.ignored\u0026#34;: \u0026#34;무시된 리소스의 색상입니다.\u0026#34;, \u0026#34;colors.conflict\u0026#34;: \u0026#34;충돌이 발생한 리소스의 색상입니다.\u0026#34;, \u0026#34;colors.submodule\u0026#34;: \u0026#34;서브모듈 자원의 색상\u0026#34;, \u0026#34;view.workbench.scm.missing\u0026#34;: \u0026#34;유효한 Git 설치가 검색되지 않았습니다. [Git 출력](command:git.showOutput)에서 자세한 내용을 확인할 수 있습니다.\\r\\n[Git을 설치하거나](https://git-scm.com/) [Microsoft Docs](https://aka.ms/vscode-scm)에서 VS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보세요.\\r\\n다른 버전 제어 시스템을 사용하는 경우 추가 확장에 대해 [Marketplace를 검색](command:workbench.extensions.search?%22%40category%3A%5C%22scm%20providers%5C%22%22)할 수 있습니다.\u0026#34;, \u0026#34;view.workbench.scm.disabled\u0026#34;: \u0026#34;Git 기능을 사용하려면 [설정]에서 Git을 사용하도록 설정하세요(command:workbench.action.openSettings?%5B%22git.enabled%22%5D).\\r\\nVS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 참조하세요.\u0026#34;, \u0026#34;view.workbench.scm.empty\u0026#34;: \u0026#34;Git 기능을 사용하려면 Git 리포지토리가 포함된 폴더를 열거나 URL에서 복제하면 됩니다.\\r\\n[폴더 열기](command:vscode.openFolder)\\n[리포지토리 복제](command:git.clone)\\r\\nVS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 참조하세요.\u0026#34;, \u0026#34;view.workbench.scm.folder\u0026#34;: \u0026#34;현재 열린 폴더에 Git 리포지토리가 없습니다. Git에서 제공하는 소스 제어 기능을 사용하도록 설정할 리포지토리를 초기화할 수 있습니다.\\r\\n[리포지토리 초기화](command:git.init?%5Btrue%5D)\\r\\nVS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 읽어보세요.\u0026#34;, \u0026#34;view.workbench.scm.workspace\u0026#34;: \u0026#34;현재 열린 작업 영역에 Git 리포지토리가 포함된 폴더가 없습니다. Git에서 제공하는 소스 제어 기능을 사용하도록 설정할 폴더의 리포지토리를 초기화할 수 있습니다.\\r\\n[리포지토리 초기화](command:git.init)\\r\\nVS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 읽어보세요.\u0026#34;, \u0026#34;view.workbench.scm.emptyWorkspace\u0026#34;: \u0026#34;현재 열린 작업 영역에 Git 리포지토리를 포함하는 폴더가 없습니다.\\r\\n[작업 영역에 폴더 추가](command:workbench.action.addRootFolder)\\r\\nVS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 참조하세요.\u0026#34;, \u0026#34;view.workbench.cloneRepository\u0026#34;: \u0026#34;URL에서 리포지토리를 복제할 수도 있습니다. VS Code에서 Git 및 소스 제어를 사용하는 방법에 대해 자세히 알아보려면 [Microsoft Docs](https://aka.ms/vscode-scm)를 참조하세요.\\r\\n[리포지토리 복제](command:git.clone)\u0026#34; }, \u0026#34;dist/repository\u0026#34;: { \u0026#34;index modified\u0026#34;: \u0026#34;인덱스 수정됨\u0026#34;, \u0026#34;modified\u0026#34;: \u0026#34;수정\u0026#34;, \u0026#34;index added\u0026#34;: \u0026#34;인덱스 추가됨\u0026#34;, \u0026#34;index deleted\u0026#34;: \u0026#34;인덱스 삭제됨\u0026#34;, \u0026#34;deleted\u0026#34;: \u0026#34;삭제\u0026#34;, \u0026#34;index renamed\u0026#34;: \u0026#34;인덱스 이름 변경됨\u0026#34;, \u0026#34;index copied\u0026#34;: \u0026#34;인덱스 복사됨\u0026#34;, \u0026#34;untracked\u0026#34;: \u0026#34;추적되지 않음\u0026#34;, \u0026#34;ignored\u0026#34;: \u0026#34;무시됨\u0026#34;, \u0026#34;intent to add\u0026#34;: \u0026#34;추가할 의도\u0026#34;, \u0026#34;both deleted\u0026#34;: \u0026#34;둘 다 삭제됨\u0026#34;, \u0026#34;added by us\u0026#34;: \u0026#34;본인이 추가함\u0026#34;, \u0026#34;deleted by them\u0026#34;: \u0026#34;타인이 삭제함\u0026#34;, \u0026#34;added by them\u0026#34;: \u0026#34;타인이 추가함\u0026#34;, \u0026#34;deleted by us\u0026#34;: \u0026#34;본인이 삭제함\u0026#34;, \u0026#34;both added\u0026#34;: \u0026#34;둘 다 추가됨\u0026#34;, \u0026#34;both modified\u0026#34;: \u0026#34;둘 다 수정됨\u0026#34;, \u0026#34;open\u0026#34;: \u0026#34;열기\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;커밋\u0026#34;, \u0026#34;merge changes\u0026#34;: \u0026#34;변경 사항 병합\u0026#34;, \u0026#34;staged changes\u0026#34;: \u0026#34;스테이징된 변경 사항\u0026#34;, \u0026#34;changes\u0026#34;: \u0026#34;변경 사항\u0026#34;, \u0026#34;untracked changes\u0026#34;: \u0026#34;추적되지 않은 변경 사항\u0026#34;, \u0026#34;push success\u0026#34;: \u0026#34;성공적으로 푸시 되었습니다.\u0026#34;, \u0026#34;commit in rebase\u0026#34;: \u0026#34;기준 주소를 다시 지정하는 중에는 커밋 메시지를 변경할 수 없습니다. 기준 주소 다시 지정 작업을 완료하고, 대신 대화형 기준 주소 다시 지정을 사용하세요.\u0026#34;, \u0026#34;commitMessageWhitespacesOnlyWarning\u0026#34;: \u0026#34;현재 커밋 메시지에는 공백 문자만 포함됩니다.\u0026#34;, \u0026#34;commitMessageCountdown\u0026#34;: \u0026#34;현재 줄에서 {0} 글자 남음\u0026#34;, \u0026#34;commitMessageWarning\u0026#34;: \u0026#34;현재 줄에서 {0} 글자 초과 {1}\u0026#34;, \u0026#34;sync is unpredictable\u0026#34;: \u0026#34;동기화 중입니다. 취소하면 리포지토리가 손상될 수 있습니다.\u0026#34;, \u0026#34;huge\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39;의 Git 리포지토리에 활성 변경 내용이 너무 많습니다. Git 기능의 하위 집합만 사용할 수 있도록 설정됩니다.\u0026#34;, \u0026#34;neveragain\u0026#34;: \u0026#34;다시 표시 안 함\u0026#34;, \u0026#34;add known\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39;을(를) .gitignore에 추가하시겠어요?\u0026#34;, \u0026#34;yes\u0026#34;: \u0026#34;예\u0026#34;, \u0026#34;sync changes\u0026#34;: \u0026#34;변경 내용 동기화\u0026#34;, \u0026#34;pull n\u0026#34;: \u0026#34;{1}/{2}에서 {0}개 커밋 풀\u0026#34;, \u0026#34;push n\u0026#34;: \u0026#34;{1}/{2}(으)로 {0}개 커밋 푸시\u0026#34;, \u0026#34;pull push n\u0026#34;: \u0026#34;{2}/{3} 간에 {0}개 커밋 풀 및 {1}개 커밋 푸시\u0026#34;, \u0026#34;commitMessageWithHeadLabel\u0026#34;: \u0026#34;메시지(\u0026#39;{1}\u0026#39;에서 커밋할 {0})\u0026#34;, \u0026#34;commitMessage\u0026#34;: \u0026#34;메시지(커밋할 {0})\u0026#34; }, \u0026#34;dist/main\u0026#34;: { \u0026#34;looking\u0026#34;: \u0026#34;다음에서 git을 찾는 중: {0}\u0026#34;, \u0026#34;using git\u0026#34;: \u0026#34;{1}에서 git {0}을(를) 사용하는 중\u0026#34;, \u0026#34;downloadgit\u0026#34;: \u0026#34;Git 다운로드\u0026#34;, \u0026#34;neverShowAgain\u0026#34;: \u0026#34;다시 표시 안 함\u0026#34;, \u0026#34;notfound\u0026#34;: \u0026#34;Git을 찾을 수 없습니다. \u0026#39;git.path\u0026#39;를 사용하여 Git을 설치하거나 구성합니다.\u0026#34;, \u0026#34;updateGit\u0026#34;: \u0026#34;Git 업데이트\u0026#34;, \u0026#34;git20\u0026#34;: \u0026#34;Git {0}이(가) 설치된 것 같습니다. 코드는 2 이하의 Git에서 최적으로 작동합니다.\u0026#34;, \u0026#34;git2526\u0026#34;: \u0026#34;설치된 Git {0}에 알려진 문제가 있습니다. Git 기능이 제대로 작동하도록 하려면 2.27 이상의 Git으로 업데이트하세요.\u0026#34; }, \u0026#34;dist/remoteSource\u0026#34;: { \u0026#34;type to search\u0026#34;: \u0026#34;리포지토리 이름(입력하여 검색)\u0026#34;, \u0026#34;type to filter\u0026#34;: \u0026#34;리포지토리 이름\u0026#34;, \u0026#34;none found\u0026#34;: \u0026#34;원격 리포지토리를 찾을 수 없습니다.\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;$(error) 오류: {0}\u0026#34;, \u0026#34;provide url\u0026#34;: \u0026#34;리포지토리 URL 제공\u0026#34;, \u0026#34;provide url or pick\u0026#34;: \u0026#34;리포지토리 URL을 입력하거나 리포지토리 소스를 선택하세요.\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;URL\u0026#34;, \u0026#34;pick url\u0026#34;: \u0026#34;복제할 URL을 선택하세요.\u0026#34; }, \u0026#34;dist/timelineProvider\u0026#34;: { \u0026#34;git.timeline.source\u0026#34;: \u0026#34;Git 기록\u0026#34;, \u0026#34;git.timeline.you\u0026#34;: \u0026#34;사용자\u0026#34;, \u0026#34;git.timeline.stagedChanges\u0026#34;: \u0026#34;스테이징된 변경 내용\u0026#34;, \u0026#34;git.timeline.detail\u0026#34;: \u0026#34;{0} — {1}\\r\\n{2}\\r\\n\\r\\n{3}\u0026#34;, \u0026#34;git.index\u0026#34;: \u0026#34;인덱스\u0026#34;, \u0026#34;git.timeline.uncommitedChanges\u0026#34;: \u0026#34;커밋되지 않은 변경 내용\u0026#34;, \u0026#34;git.workingTree\u0026#34;: \u0026#34;작업 트리\u0026#34; }, \u0026#34;dist/model\u0026#34;: { \u0026#34;not supported\u0026#34;: \u0026#34;\u0026#39;git.scanRepositories\u0026#39; 설정에서는 절대 경로를 사용할 수 없습니다.\u0026#34;, \u0026#34;too many submodules\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39; 리포지토리에 자동으로 열리지 않는 {1}개의 하위 모듈이 있습니다. 모듈 내의 파일을 열러 각 모듈을 개별적으로 열 수는 있습니다.\u0026#34;, \u0026#34;no repositories\u0026#34;: \u0026#34;사용 가능한 리포지토리가 없습니다.\u0026#34;, \u0026#34;pick repo\u0026#34;: \u0026#34;리포지토리 선택\u0026#34; }, \u0026#34;dist/autofetch\u0026#34;: { \u0026#34;yes\u0026#34;: \u0026#34;예\u0026#34;, \u0026#34;no\u0026#34;: \u0026#34;아니요\u0026#34;, \u0026#34;not now\u0026#34;: \u0026#34;나중에 물어보기\u0026#34;, \u0026#34;suggest auto fetch\u0026#34;: \u0026#34;Code에서 [\u0026#39;git fetch\u0026#39;]({0})를 정기적으로 실행하도록 하시겠습니까?\u0026#34; }, \u0026#34;dist/statusbar\u0026#34;: { \u0026#34;rebasing\u0026#34;: \u0026#34;기준 주소 다시 지정\u0026#34;, \u0026#34;checkout\u0026#34;: \u0026#34;분기/태그 체크 아웃...\u0026#34;, \u0026#34;publish to\u0026#34;: \u0026#34;{0}에 게시\u0026#34;, \u0026#34;publish to...\u0026#34;: \u0026#34;다음에 게시...\u0026#34;, \u0026#34;publish changes\u0026#34;: \u0026#34;변경 내용 게시\u0026#34;, \u0026#34;syncing changes\u0026#34;: \u0026#34;변경 내용을 동기화하는 중...\u0026#34; }, \u0026#34;dist/commands\u0026#34;: { \u0026#34;tag at\u0026#34;: \u0026#34;{0}의 태그\u0026#34;, \u0026#34;remote branch at\u0026#34;: \u0026#34;{0}에서 원격 분기\u0026#34;, \u0026#34;create branch\u0026#34;: \u0026#34;새 분기 만들기...\u0026#34;, \u0026#34;create branch from\u0026#34;: \u0026#34;...에서 새 분기 만들기\u0026#34;, \u0026#34;add remote\u0026#34;: \u0026#34;새 원격 추가...\u0026#34;, \u0026#34;current\u0026#34;: \u0026#34;현재\u0026#34;, \u0026#34;select log level\u0026#34;: \u0026#34;로그 수준 선택\u0026#34;, \u0026#34;changed\u0026#34;: \u0026#34;로그 수준이 {0}(으)로 변경되었습니다.\u0026#34;, \u0026#34;git.title.index\u0026#34;: \u0026#34;{0}(인덱스)\u0026#34;, \u0026#34;git.title.workingTree\u0026#34;: \u0026#34;{0}(작업 트리)\u0026#34;, \u0026#34;git.title.theirs\u0026#34;: \u0026#34;{0}(다른 사용자의 변경 내용)\u0026#34;, \u0026#34;git.title.ours\u0026#34;: \u0026#34;{0}(우리의 변경 내용)\u0026#34;, \u0026#34;git.title.untracked\u0026#34;: \u0026#34;{0}(추적되지 않음)\u0026#34;, \u0026#34;clonefrom\u0026#34;: \u0026#34;{0}에서 복제\u0026#34;, \u0026#34;repourl\u0026#34;: \u0026#34;리포지토리 URL\u0026#34;, \u0026#34;selectFolder\u0026#34;: \u0026#34;리포지토리 위치 선택\u0026#34;, \u0026#34;cloning\u0026#34;: \u0026#34;Git 리포지토리 \u0026#39;{0}\u0026#39;을(를) 복제하는 중...\u0026#34;, \u0026#34;proposeopen\u0026#34;: \u0026#34;복제된 리포지토리를 여시겠습니까?\u0026#34;, \u0026#34;openrepo\u0026#34;: \u0026#34;열기\u0026#34;, \u0026#34;openreponew\u0026#34;: \u0026#34;새 창에서 열기\u0026#34;, \u0026#34;add\u0026#34;: \u0026#34;작업 영역에 추가\u0026#34;, \u0026#34;proposeopen2\u0026#34;: \u0026#34;복제된 리포지토리를 열거나 현재 작업 영역에 추가하시겠습니까?\u0026#34;, \u0026#34;init\u0026#34;: \u0026#34;Git 리포지토리를 초기화할 작업 영역 폴더 선택\u0026#34;, \u0026#34;choose\u0026#34;: \u0026#34;폴더 선택...\u0026#34;, \u0026#34;init repo\u0026#34;: \u0026#34;리포지토리 초기화\u0026#34;, \u0026#34;create repo\u0026#34;: \u0026#34;리포지토리 초기화\u0026#34;, \u0026#34;are you sure\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39;에서 Git 리포지토리가 만들어집니다. 계속하시겠습니까?\u0026#34;, \u0026#34;proposeopen init\u0026#34;: \u0026#34;초기화된 리포지토리를 여시겠습니까?\u0026#34;, \u0026#34;proposeopen2 init\u0026#34;: \u0026#34;초기화된 리포지토리를 열거나 현재 작업 영역에 추가하겠습니까?\u0026#34;, \u0026#34;open repo\u0026#34;: \u0026#34;리포지토리 열기\u0026#34;, \u0026#34;HEAD not available\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39;의 HEAD 버전이 없습니다.\u0026#34;, \u0026#34;confirm stage files with merge conflicts\u0026#34;: \u0026#34;병합 충돌이 있는 {0} 파일을 스테이징하시겠습니까?\u0026#34;, \u0026#34;confirm stage file with merge conflicts\u0026#34;: \u0026#34;병합 충돌이 있는 {0}을(를) 스테이징하시겠습니까?\u0026#34;, \u0026#34;yes\u0026#34;: \u0026#34;예\u0026#34;, \u0026#34;keep ours\u0026#34;: \u0026#34;현재 버전 유지\u0026#34;, \u0026#34;delete\u0026#34;: \u0026#34;파일 삭제\u0026#34;, \u0026#34;deleted by them\u0026#34;: \u0026#34;다른 사용자가 삭제한 \u0026#39;{0}\u0026#39; 파일을 Microsoft에서 수정했습니다.\\r\\n\\r\\n원하는 작업을 선택하세요.\u0026#34;, \u0026#34;keep theirs\u0026#34;: \u0026#34;다른 사용자 버전 유지\u0026#34;, \u0026#34;deleted by us\u0026#34;: \u0026#34;본인이 \u0026#39;{0}\u0026#39; 파일을 삭제하고 타인이 수정했습니다.\\r\\n\\r\\n수행하고 싶은 작업을 선택하세요.\u0026#34;, \u0026#34;discard\u0026#34;: \u0026#34;변경 내용 취소\u0026#34;, \u0026#34;confirm delete\u0026#34;: \u0026#34;{0}을(를) 삭제하시겠습니까?\\r\\n이 작업은 취소할 수 없습니다!\\r\\n계속하면 이 파일이 영구적으로 손실됩니다.\u0026#34;, \u0026#34;delete file\u0026#34;: \u0026#34;파일 삭제\u0026#34;, \u0026#34;restore file\u0026#34;: \u0026#34;파일 복원\u0026#34;, \u0026#34;confirm restore\u0026#34;: \u0026#34;{0}을(를) 복원하시겠습니까?\u0026#34;, \u0026#34;confirm discard\u0026#34;: \u0026#34;{0}의 변경 내용을 취소하시겠습니까?\u0026#34;, \u0026#34;restore files\u0026#34;: \u0026#34;파일 복원\u0026#34;, \u0026#34;confirm restore multiple\u0026#34;: \u0026#34;{0}개 파일을 복원하겠습니까?\u0026#34;, \u0026#34;confirm discard multiple\u0026#34;: \u0026#34;{0}개 파일의 변경 내용을 취소하시겠습니까?\u0026#34;, \u0026#34;warn untracked\u0026#34;: \u0026#34;이렇게 하면 추적되지 않은 파일 {0}개가 삭제됩니다!\\r\\n삭제 후에는 되돌릴 수 없습니다!\\r\\n이 파일은 영구적으로 손실됩니다.\u0026#34;, \u0026#34;there are untracked files single\u0026#34;: \u0026#34;취소한 경우 다음 추적되지 않은 파일이 디스크에서 삭제됩니다. {0}.\u0026#34;, \u0026#34;there are untracked files\u0026#34;: \u0026#34;취소하는 경우 {0}개의 추적되지 않은 파일이 디스크에서 삭제됩니다.\u0026#34;, \u0026#34;confirm discard all 2\u0026#34;: \u0026#34;{0}\\r\\n\\r\\n이 작업은 되돌릴 수 없으며, 현재 작업 집합이 영구적으로 손실됩니다.\u0026#34;, \u0026#34;yes discard tracked\u0026#34;: \u0026#34;1개의 추적된 파일 취소\u0026#34;, \u0026#34;yes discard tracked multiple\u0026#34;: \u0026#34;{0}개의 추적된 파일 취소\u0026#34;, \u0026#34;discardAll\u0026#34;: \u0026#34;{0}개 파일 모두 버리기\u0026#34;, \u0026#34;confirm discard all single\u0026#34;: \u0026#34;{0}의 변경 내용을 취소하시겠습니까?\u0026#34;, \u0026#34;confirm discard all\u0026#34;: \u0026#34;파일 {0}개의 변경 내용을 모두 취소하시겠습니까?\\r\\n이 작업은 취소할 수 없습니다!\\r\\n계속하면 현재 작업 집합이 영구적으로 손실됩니다.\u0026#34;, \u0026#34;discardAll multiple\u0026#34;: \u0026#34;1개 파일 취소\u0026#34;, \u0026#34;confirm delete multiple\u0026#34;: \u0026#34;파일 {0}개를 삭제하시겠습니까?\\r\\n이 작업은 취소할 수 없습니다!\\r\\n계속하면 해당 파일이 영구적으로 손실됩니다.\u0026#34;, \u0026#34;delete files\u0026#34;: \u0026#34;파일 삭제\u0026#34;, \u0026#34;unsaved files single\u0026#34;: \u0026#34;계속하는 경우 {0} 파일의 저장되지 않은 변경 내용이 커밋에 포함되지 않을 수 있습니다.\\r\\n\\r\\n커밋하기 전에 저장하시겠습니까?\u0026#34;, \u0026#34;unsaved files\u0026#34;: \u0026#34;저장되지 않은 파일 {0}개가 있습니다.\\r\\n\\r\\n커밋하기 전에 저장하시겠습니까?\u0026#34;, \u0026#34;save and commit\u0026#34;: \u0026#34;모두 저장 및 커밋\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;커밋\u0026#34;, \u0026#34;no staged changes\u0026#34;: \u0026#34;커밋할 스테이징된 변경 사항이 없습니다.\\r\\n\\r\\n모든 변경 사항을 스테이징하고 직접 커밋하시겠습니까?\u0026#34;, \u0026#34;always\u0026#34;: \u0026#34;항상\u0026#34;, \u0026#34;never\u0026#34;: \u0026#34;안 함\u0026#34;, \u0026#34;no changes\u0026#34;: \u0026#34;커밋할 변경 내용이 없습니다.\u0026#34;, \u0026#34;no verify commit not allowed\u0026#34;: \u0026#34;확인 없는 커밋은 허용되지 않습니다. \u0026#39;git.allowNoVerifyCommit\u0026#39; 설정을 통해 사용하도록 설정하세요.\u0026#34;, \u0026#34;confirm no verify commit\u0026#34;: \u0026#34;확인 없이 변경 내용을 커밋하려고 합니다. 그러면 pre-commit 후크를 건너뛰고 바람직하지 않을 수 있습니다.\\r\\n\\r\\n계속하시겠습니까?\u0026#34;, \u0026#34;ok\u0026#34;: \u0026#34;확인\u0026#34;, \u0026#34;never ask again\u0026#34;: \u0026#34;네, 다시 표시 안 함\u0026#34;, \u0026#34;commitMessageWithHeadLabel2\u0026#34;: \u0026#34;메시지(\u0026#39;{0}\u0026#39;에서 커밋)\u0026#34;, \u0026#34;commit message\u0026#34;: \u0026#34;커밋 메시지\u0026#34;, \u0026#34;provide commit message\u0026#34;: \u0026#34;커밋 메시지를 제공하세요.\u0026#34;, \u0026#34;confirm emtpy commit\u0026#34;: \u0026#34;빈 커밋을 만드시겠습니까?\u0026#34;, \u0026#34;yes never again\u0026#34;: \u0026#34;예, 다시 표시 안 함\u0026#34;, \u0026#34;no more\u0026#34;: \u0026#34;HEAD가 커밋을 가리키지 않으므로 실행 취소할 수 없습니다.\u0026#34;, \u0026#34;undo commit\u0026#34;: \u0026#34;병합 커밋 실행 취소\u0026#34;, \u0026#34;merge commit\u0026#34;: \u0026#34;마지막 커밋은 병합 커밋이었습니다. 실행 취소하시겠습니까?\u0026#34;, \u0026#34;select a ref to checkout\u0026#34;: \u0026#34;체크아웃할 참조 선택\u0026#34;, \u0026#34;branch name\u0026#34;: \u0026#34;분기 이름\u0026#34;, \u0026#34;provide branch name\u0026#34;: \u0026#34;새 분기 이름을 제공하세요.\u0026#34;, \u0026#34;branch name format invalid\u0026#34;: \u0026#34;분기 이름은 regex {0}과(와) 일치해야 합니다.\u0026#34;, \u0026#34;select a ref to create a new branch from\u0026#34;: \u0026#34;ref를 선택하여 다음에서 \u0026#39;{0}\u0026#39; 분기를 만듭니다.\u0026#34;, \u0026#34;select branch to delete\u0026#34;: \u0026#34;삭제할 분기 선택\u0026#34;, \u0026#34;confirm force delete branch\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39; 분기가 완벽히 병합되지 않았습니다. 그래도 삭제할까요?\u0026#34;, \u0026#34;delete branch\u0026#34;: \u0026#34;분기 삭제\u0026#34;, \u0026#34;invalid branch name\u0026#34;: \u0026#34;잘못된 분기 이름\u0026#34;, \u0026#34;branch already exists\u0026#34;: \u0026#34;이름이 \u0026#39;{0}\u0026#39;인 분기가 이미 있습니다.\u0026#34;, \u0026#34;select a branch to merge from\u0026#34;: \u0026#34;병합할 분기 선택\u0026#34;, \u0026#34;select a branch to rebase onto\u0026#34;: \u0026#34;다시 지정할 대상 분기 선택\u0026#34;, \u0026#34;tag name\u0026#34;: \u0026#34;태그 이름\u0026#34;, \u0026#34;provide tag name\u0026#34;: \u0026#34;태그 이름을 입력하세요.\u0026#34;, \u0026#34;tag message\u0026#34;: \u0026#34;메시지\u0026#34;, \u0026#34;provide tag message\u0026#34;: \u0026#34;태그에 주석을 달 메시지를 입력하세요.\u0026#34;, \u0026#34;no tags\u0026#34;: \u0026#34;이 리포지토리에는 태그가 없습니다.\u0026#34;, \u0026#34;select a tag to delete\u0026#34;: \u0026#34;삭제할 태그 선택\u0026#34;, \u0026#34;no remotes to fetch\u0026#34;: \u0026#34;이 리포지토리에 페치할 원격 항목이 구성되어 있지 않습니다.\u0026#34;, \u0026#34;no remotes to pull\u0026#34;: \u0026#34;리포지토리에 풀하도록 구성된 원격 항목이 없습니다.\u0026#34;, \u0026#34;pick remote pull repo\u0026#34;: \u0026#34;분기를 가져올 원격 선택\u0026#34;, \u0026#34;pick branch pull\u0026#34;: \u0026#34;다음에서 가져올 분기 선택\u0026#34;, \u0026#34;addremote\u0026#34;: \u0026#34;원격 추가\u0026#34;, \u0026#34;no remotes to push\u0026#34;: \u0026#34;리포지토리에 푸시하도록 구성된 원격이 없습니다.\u0026#34;, \u0026#34;force push not allowed\u0026#34;: \u0026#34;강제 푸시가 허용되지 않습니다. \u0026#39;git.allowForcePush\u0026#39; 설정으로 사용하도록 설정하세요.\u0026#34;, \u0026#34;confirm force push\u0026#34;: \u0026#34;변경 내용을 강제로 푸시하려고 합니다. 이렇게 하면 다른 사람의 변경 내용을 무시하거나 의도하지 않게 덮어쓸 수 있습니다.\\r\\n\\r\\n계속하시겠습니까?\u0026#34;, \u0026#34;nobranch\u0026#34;: \u0026#34;원격에 푸시할 분기를 체크 아웃하세요.\u0026#34;, \u0026#34;confirm publish branch\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39; 분기에는 상향 분기가 없습니다. 이 분기를 게시하시겠습니까?\u0026#34;, \u0026#34;pick remote\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39; 분기를 다음에 게시하려면 원격을 선택하세요.\u0026#34;, \u0026#34;addfrom\u0026#34;: \u0026#34;{0}에서 원격 추가\u0026#34;, \u0026#34;addFrom\u0026#34;: \u0026#34;URL에서 원격 추가\u0026#34;, \u0026#34;remote name\u0026#34;: \u0026#34;원격 이름\u0026#34;, \u0026#34;provide remote name\u0026#34;: \u0026#34;원격 이름을 제공하세요.\u0026#34;, \u0026#34;remote name format invalid\u0026#34;: \u0026#34;잘못된 원격 이름 형식\u0026#34;, \u0026#34;remote already exists\u0026#34;: \u0026#34;원격 \u0026#39;{0}\u0026#39;이(가) 이미 존재합니다.\u0026#34;, \u0026#34;no remotes added\u0026#34;: \u0026#34;리포지토리에 원격 항목이 없습니다.\u0026#34;, \u0026#34;remove remote\u0026#34;: \u0026#34;제거할 원격 선택\u0026#34;, \u0026#34;sync is unpredictable\u0026#34;: \u0026#34;이 작업은 \u0026#39;{0}/{1}\u0026#39;(으)로 커밋을 푸시하고 풀합니다.\u0026#34;, \u0026#34;never again\u0026#34;: \u0026#34;다시 표시 안 함\u0026#34;, \u0026#34;no remotes to publish\u0026#34;: \u0026#34;리포지토리에 게시하도록 구성된 원격이 없습니다.\u0026#34;, \u0026#34;publish to\u0026#34;: \u0026#34;{0}에 게시\u0026#34;, \u0026#34;pick provider\u0026#34;: \u0026#34;\u0026#39;{0}\u0026#39; 분기를 다음에 게시할 공급자 선택:\u0026#34;, \u0026#34;no changes stash\u0026#34;: \u0026#34;스태시할 변경 내용이 없습니다.\u0026#34;, \u0026#34;provide stash message\u0026#34;: \u0026#34;필요한 경우 스태시 메시지를 입력하세요.\u0026#34;, \u0026#34;stash message\u0026#34;: \u0026#34;스태시 메시지\u0026#34;, \u0026#34;pick stash to pop\u0026#34;: \u0026#34;표시할 스태시 선택\u0026#34;, \u0026#34;no stashes\u0026#34;: \u0026#34;리포지토리에 스태시가 없습니다.\u0026#34;, \u0026#34;pick stash to apply\u0026#34;: \u0026#34;적용할 스태시 선택\u0026#34;, \u0026#34;pick stash to drop\u0026#34;: \u0026#34;삭제할 스태시 선택\u0026#34;, \u0026#34;git.title.diffRefs\u0026#34;: \u0026#34;{0}({1}) ⟷ {0}({2})\u0026#34;, \u0026#34;no rebase\u0026#34;: \u0026#34;진행 중인 다시 지정이 없습니다.\u0026#34;, \u0026#34;open git log\u0026#34;: \u0026#34;Git 로그 열기\u0026#34;, \u0026#34;clean repo\u0026#34;: \u0026#34;체크 아웃하기 전에 리포지토리 작업 트리를 정리하세요.\u0026#34;, \u0026#34;cant push\u0026#34;: \u0026#34;참조를 원격에 푸시할 수 없습니다. 먼저 \u0026#39;풀\u0026#39;을 실행하여 변경 내용을 통합하세요.\u0026#34;, \u0026#34;merge conflicts\u0026#34;: \u0026#34;병합 충돌이 있습니다. 해결한 후 계속하세요.\u0026#34;, \u0026#34;stash merge conflicts\u0026#34;: \u0026#34;스태시를 적용하는 중 병합 충돌이 발생했습니다.\u0026#34;, \u0026#34;auth failed specific\u0026#34;: \u0026#34;원격 Git에 인증하지 못했습니다.\\r\\n\\r\\n{0}\u0026#34;, \u0026#34;auth failed\u0026#34;: \u0026#34;git remote에 인증하지 못했습니다.\u0026#34;, \u0026#34;missing user info\u0026#34;: \u0026#34;Git에서 \u0026#39;user.name\u0026#39; 및 \u0026#39;user.email\u0026#39;을 구성하세요.\u0026#34;, \u0026#34;learn more\u0026#34;: \u0026#34;자세한 정보\u0026#34;, \u0026#34;git error details\u0026#34;: \u0026#34;Git: {0}\u0026#34;, \u0026#34;git error\u0026#34;: \u0026#34;Git 오류\u0026#34; }, \u0026#34;dist/askpass-main\u0026#34;: { \u0026#34;missOrInvalid\u0026#34;: \u0026#34;자격 증명이 없거나 잘못되었습니다.\u0026#34; } } } ","date":"2022-11-10T06:21:00Z","image":"https://blog.realsn.com/p/vscode%EC%97%90%EC%84%9C-git-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%84%A4%EC%A0%95%EA%B0%92-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/thumb_hub264a34a1b33755d024e9ef4d5879533_9613_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/vscode%EC%97%90%EC%84%9C-git-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%84%A4%EC%A0%95%EA%B0%92-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/","title":"VScode에서 Git 사용자 설정값 변경하기"},{"content":"IntersectionObserver API IntersectionObserver API 는 브라우저의 Viewport와, 지정한 요소 (Element)의 교차점을 관찰하는 기능을 제공합니다. 교차점을 감지해 \u0026lsquo;원하는 위치\u0026rsquo;에 \u0026lsquo;지정한 요소가 노출되고있는지\u0026rsquo;를 확인 가능하며, callback을 통해 기능을 연결 할 수 있습니다. mdn문서에 따르면, 웹이 성숙해짐과 동시에 퍼포먼스를 챙기며 필요한 기능들을 구현하기 위해서는 IntersectionObserver API가 필요하다고 말합니다. 예를 들어 무한 스크롤로 더 많은 콘텐츠가 로드되고 렌더링 되는 웹사이트를 만든다거나, 스크롤 시 노출시킬 컨텐츠 구현 등에서 많은 사용이 필요하겠죠.\naddEventListener(\u0026ldquo;scroll\u0026rdquo;) 과의 차이 scroll 이벤트를 사용하는 것 보다, 해당 문서의 API를 이용해야하는 가장 중요한 이유는 브라우저의 부하를 고려, 한마디로 퍼포먼스를 고려한 스크립트를 위함입니다. mdn 문서 뿐만 아니라, 해당 API를 소개하는 글에서는 입을 모아 말하는 이슈인것 같구요.\n과거에 교차 감지를 구현하려면 Element.getBoundingClientRect()영향을 받는 모든 요소에 필요한 정보를 구축하는 것과 같은 메서드를 호출하는 이벤트 핸들러 및 루프가 필요했습니다. 이 코드는 모두 메인 스레드에서 실행되기 때문에 이 중 하나라도 성능 문제를 일으킬 수 있습니다. 사이트에 이러한 테스트가 로드되면 상황이 완전히 나빠질 수 있습니다.\nMDN의 해당 API 소개글에 나온 위 내용과 같이 기존의 addEventListener 를 통한 \u0026ldquo;scroll\u0026rdquo; 이벤트를 사용할 경우, 메인 스레드에서의 재실행이 반복됨으로서 렌더링 성능이나 이벤트 연속 호출과 같은 문제가 발생합니다. 이와같은 치명적인 허점을 보완하기 위해 나온 JS API가 IntersectionObserver API 입니다. 무엇보다 메인 스레드에서의 실행이 아닌, 브라우저를 감지 후 특정 시점에서 비동기로 실행이 되는 덕에 웹 퍼포먼스에서의 상당한 이득을 볼 수 있습니다.\nIntersectionObserver 사용방법 해당 API 사용시 필요한 내용들입니다.\n이벤트를 실행시킬 element Observer API 에 사용할 options\n2-1) 지정될 ViewPort\n2-2) Viewport에서의 Margin값 ( ViewPort 크기를 임의로 늘이거나, 줄임 )\n2-3) Viewport와 엘리먼트의 교차가 몇 %이어야 API가 감지를 실행하는지에 대한 값. API 선언 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let options = { root: document.querySelector(\u0026#34;#scrollArea\u0026#34;), // default: null rootMargin: \u0026#34;0px\u0026#34;, // 상단 내용에서 말한 2-2, Viewport의 마진값 지정으로 // Viewport의 크기를 늘이거나 줄일수 있습니다. // ★ 단위값 ( px || % )가 필수임. threshold: 1.0, // 상단 내용 2-3, 엘리먼트 백분율 기준 Viewport와의 교차정도를 지정할수 있음. // ex ) threshold: 1.0 == 100% 교차 // ex ) threshold: 0.5 == 50% 교차 // ★ 1 이상의 값은 정의 불가 }; let observer = new IntersectionObserver(callback, options); // API 생성, 지정한 옵션값을 토대로 브라우저를 감지하며, 감지 될 경우 callback 함수 실행 observe 대상 지정하기 먼저 Viewport안에 노출되고있는지 확인하고싶은 대상 엘리먼트를 선언해보고자 합니다. 바로 위 코드블럭의 18번째 줄을 그대로 사용한 후, observe시킬 대상을 연결합니다.\n1 2 let observer = new IntersectionObserver(callback, options); observer.observe(\u0026#34;대상 엘리먼트\u0026#34;); 새로 API를 선언한 후 변수에 담은 후, 그 뒤에 다시 observe 를 연결하여 대상 엘리먼트를 연결합니다. 현재 options 값과 callback시킬 함수가 없어 작동되지 않고 있지만요. 포스팅의 threshold 에서 테스트용 엘리먼트를 불러올 예정입니다.\noptions 값의 rootMargin 기본적으로 px 또는 % 값이 필수로 들어가야합니다.\ncss - margin 과 유사한 속성으로 선언이 가능하며, 지정한 값 만큼 Viewport를 늘이거나 줄일 수 있습니다. 해당 페이지를 예로 들어보겠습니다.\noptions.rootMargin 값을 \u0026lsquo;0px\u0026rsquo; 또는 \u0026lsquo;0%\u0026lsquo;로 지정했을 때의 Viewport 영역입니다.\noptions.rootMargin 값을 \u0026lsquo;0px 0px 150px 0px\u0026rsquo; 로 지정했을 때의 Viewport 영역입니다. 보이는것처럼, 기존 Viewport의 화면보다 지정한 값 만큼 viewport가 늘어나게 됩니다.\noptions.rootMargin 값을 \u0026lsquo;0px 0px 150px -200px\u0026rsquo; 로 지정했을 때의 Viewport 영역입니다. 마찬가지로, 기존 Viewport상에서 -200px 만큼 빠진 영역이 Viewport가 됩니다.\n실전에서 예를 들어보자면, 저는 해당 기술을 사용하면서 브라우저의 가운데만을 Viewport로 삼은 후 지정한 엘리먼트가 브라우저의 가운데 영역과 완전히 겹쳤을 때 Observer 실행이 이루어지는 기능을 구현하고싶었습니다. 그러기 위해서는 Viewport의 위치를 먼저 지정해줘야했고, 가장 자연스러운 위치를 계산한 결과 나온 Viewport 의 영역은\nrootMargin: '-25% 0% -25% 0%' 해당 사진과 같은 Viewport 입니다.\n계산과 같이 Viewport의 height 값이 472px 로 잘 잡혀주었습니다.\noptions 값의 threshold 위 rootMargin에 의해 세팅된 Viewport 영역과 observe 시킨 대상 엘리먼트가 얼마나 겹쳤을때 감지가 이뤄지는지를 설정할 수 있습니다. 1을 100%로 계산하며, 1 초과, 0 미만의 수는 사용할 수 없습니다. (에러가 뜹니다!)\n[observe 대상 지정하기]에서 말했던 것 처럼, 겹침 대상 감지 엘리먼트를 아래처럼 위 상단의 타이틀 이미지라고 가정해봅시다.\n해당 엘리먼트를 아래와 같이 observe 시킵니다.\n1 observer.observe(document.querySelector(\u0026#34;.article-image\u0026#34;)); options.threshold 를 1로 지정했을때, 엘리먼트의 100% 영역이 Viewport와 겹쳐야만 API가 옵저버 실행을 성공할것입니다.\n1 2 3 4 var options = { ... threshold: 1 } 사진과 같이 엘리먼트가 100% Viewport와 겹쳤을 경우부터 옵저버가 실행됩니다. 다음으로는 0.5를 확인해보겠습니다.\n1 2 3 4 var options = { ... threshold: 0.5 } 엘리먼트가 50% Viewport와 겹치게 된 순간부터 옵저버가 실행됩니다.\n이 다음은 threshold 를 0으로 지정했을 때 입니다.\n1 2 3 4 var options = { ... threshold: 0 } 위와 같이 viewport와 지정 엘리먼트가 닿는 지점부터 옵저버가 실행됩니다.\noptions.threshold 는 이 뿐만 아니라, array 를 통해 연속 실행도 가능하도록 세팅이 가능합니다.\n1 2 3 4 var options = { ... threshold: 0 } 예를 들어 값을 [0, 0.3, 1]로 지정하였을 경우, threshold 감지 실행 기준이 0 일때, 0.3일 때, 1일 때를 기준으로 한번 씩 옵저버를 실행해줍니다.\n테스트! 해당 포스트에서 사용한 IntersectionObserver API의 예시입니다.\n콘솔창에 그대로 복붙하면 감지가 이뤄지는 기준을 확인할수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 document.querySelector(\u0026#34;.article-header\u0026#34;).style.paddingTop = \u0026#34;1000px\u0026#34;; var viewportDiv = document.createElement(\u0026#34;div\u0026#34;); viewportDiv.style.height = \u0026#34;50%\u0026#34;; viewportDiv.style.width = \u0026#34;100%\u0026#34;; viewportDiv.style.position = \u0026#34;fixed\u0026#34;; viewportDiv.style.top = \u0026#34;25%\u0026#34;; viewportDiv.style.left = \u0026#34;0\u0026#34;; viewportDiv.style.background = \u0026#34;lightgoldenrodyellow\u0026#34;; viewportDiv.style.opacity = \u0026#34;0.5\u0026#34;; viewportDiv.innerHTML = \u0026#34;가상 VIEWPORT - 동적으로 움직이지 않습니다.\u0026#34;; document.querySelector(\u0026#34;body\u0026#34;).append(viewportDiv); document.querySelector(\u0026#34;.article-header\u0026#34;).focus(); document.querySelector(\u0026#34;.article-header\u0026#34;).scrollIntoView(); var observer = new IntersectionObserver( (obs, ins) =\u0026gt; { // 설정값에 맞춰서 감지 후 실행할 때 타는 영역. console.log(\u0026#34;ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\u0026#34;); console.log(\u0026#34;감지!\u0026#34;); console.log(obs[0]); }, { //options root: null, rootMargin: \u0026#34;-25% 0% -25% 0%\u0026#34;, threshold: 0, } ); observer.observe(document.querySelector(\u0026#34;.article-image\u0026#34;)); entries IntersectionObserver 감지 실행 후 작동하는 callback을 통해 인스턴스에서 제공하는 기능들을 사용 가능합니다.\nboundingClientRect: 관찰 대상의 사각형 정보\nintersectionRect: 관찰 대상의 교차 영역 정보\nintersectionRatio: 관찰 대상의 교차한 영역 백분율\nisIntersecting: 관찰 대상의 교차 상태(Boolean)\nrootBounds: 지정한 루트 요소의 사각형 정보(DOMRectReadOnly)\ntarget: 관찰 대상 요소(Element)\ntime: 변경이 발생한 시간 정보(DOMHighResTimeStamp)\n작업을 하며 느낀 장점 ★ 브라우저가 리사이징 될 때의 값도 계산하여 Viewport 영역과 height를 함께 API 인스턴스에서 받아볼수 있음이 큰 장점. scroll 이벤트를 사용할 때에는 항상 퍼포먼스 이슈를 염두에 두고 작업해야했는데, 그보다 훨씬 가벼운 형태로 똑같은 기능을 구현할 수 있는 점이 큰 장점. 인스턴스에서 entries를 통해 정보값을 얻어오기 편함. (따로 엘리먼트를 선언해서, 그 값을 가져오지않아도 됨.) 교차가 제대로 이루어졌는지에 대해 Boolean값으로 확인 가능함. 참고문서 https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\nhttp://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial/\n","date":"2022-11-10T00:26:00Z","image":"https://blog.realsn.com/p/intersection-observer-api/thumb_hu232e2de08a6578f5ceeb8c7a53e589a1_41476_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/intersection-observer-api/","title":"Intersection Observer API"},{"content":"VScode 설정 GitBash VScode는 기본 터미널은 window 운영체체 특화된 PowerShell로 설정되지만, 개발 환경에는 유닉스(Unix) 환경과 레퍼런스 사용해야되므로 GitBash로 설정 변경하는 것이 권장하며, 앞으로 Node를 사용한 개발이 증가하므로, GitBash를 이용한 커맨드 명령어 사용에 익숙해야져 될 것이다.\n설정에 앞서 Git 공식사이트 최신버전을 다운받아 설치해야된다. 이후 VScode에서 터미널 기본값은 아래와 같다.\n설정창 실행 JSON 설정 파일 열기 내용 추가 1 2 3 4 5 6 7 8 { \u0026#34;terminal.integrated.profiles.windows\u0026#34;: { \u0026#34;GitBash\u0026#34;: { \u0026#34;path\u0026#34;: [\u0026#34;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\u0026#34;] } }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;GitBash\u0026#34; } GitBash 뿐만 아니라, VScode JSON 설정파일 변경은 프로젝트 환경에 따라 VScode 기본 설정을 변경해야되는 경우가 있을 수 있다.\nPrettier - Code formatter ","date":"2022-11-03T06:21:00Z","image":"https://blog.realsn.com/p/vscode-%EC%84%A4%EC%A0%95-%EB%B0%8F-%ED%99%95%EC%9E%A5%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%95%88%EB%82%B4/thumb_hufa2b549da97360a6ec9325a34f87c82b_129112_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/vscode-%EC%84%A4%EC%A0%95-%EB%B0%8F-%ED%99%95%EC%9E%A5%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%95%88%EB%82%B4/","title":"VScode 설정 및 확장플러그인 안내"},{"content":" 기초 구성 프로젝트 생성 우선 Windows 탐색기를 이용하여 프로젝트를 생성하고자 하는 경로로 이동합니다. ex) C:\\hugo\\Sites 해당 경로에서 우클릭 후 'Git Bash Here'을 클릭하여 커맨드 창을 실행합니다. 커맨드 창에서 'hugo new site [project_name]'을 입력 후 실행합니다. ex) hugo new site blog.realsn.com C:\\hugo\\Sites\\[project_name] 폴더가 생성되었다면 성공적으로 생성된 것 입니다. * ex) C:\\hugo\\Sites\\blog.realsn.com config.toml 수정 기존 내용 수정 (프로젝트 생성 시 기본적으로 선언되는 옵션 수정)\nbaseURL에 내가 만들 리소스가 배포 될 url을 입력하세요. ex)baseURL = 'https://blog.realsn.com/ title에 내가 만들 리소스의 타이틀을 지정하여 주세요. * ex)title = 'RSN UX_Lab Blog' 추가 내용 작성 (기본으로 선언되는 옵션 하단에 기재하는 추가 옵션) 1. disableKinds = ['taxonomy', 'term', 'RSS', 'sitemap']을 작성합니다. _ 기본으로 build시 생성되는 파일 중에서 Publishing Resource에 해당하지 않는 내용들을 제거합니다. 2. [outputFormats]옵션을 작성합니다. _ Hugo Build 시 산출물이 저장되는 경로를 설정합니다. * default = '/' -\u0026gt; [project_path]/public\n/layouts 구성 _defalut 구성\nbaseof.html 기본 뼈대가 되는 layout을 구성합니다. partial을 통해서 Header, Footer 등 공통 리소스를 가져와 구성합니다. list.html Build시 오류를 방지하기 위해 작성하는 파일이므로 사용하지는 않습니다. single.html [project_path]/content하위의 파일 중 front matter가 존재하는 파일의 컨텐츠가 삽입되어지는 파일 입니다. partials 구성\ninclude 될 모든 파일 shortcodes 구성 * partial.html\n/assets 구성 /js\nWebpack으로 bundling 할 resource 중 *.js파일을 저장합니다. /scss _ Webpack으로 bundling 할 resource 중 _.scss파일을 저장합니다.\n본래 용도는 JS, CSS, img등의 Resource를 저장하고 불러올 때 사용하지만 우리는 Publishing을 위한 파일을 저장합니다.\n/static 구성 /fonts\nicomoon등 font 설정 파일 중 동적 리소스만을 저장합니다. /img\nlogo등의 image파일을 저장합니다. /js\n*.js파일 중 동적 리소스를 저장하며, Webpack으로 Bundling된 resource도 이곳에 저장합니다. 형상관리 최초 project set-up시 개발리소스와 배포리소스 분리 hugo build 후 public 폴더를 먼저 배포리소스 git에 push 작업Directory에서 public 폴더 삭제 후 개발리소스 git에 push 이후에 개발리소스에서 배포리소스를 submodule로 등록 작업시작 최초 set-up 이후 git clone으로 프로젝트 내려 받은 뒤 형상 관리 개발리소스를 원하는 경로에 git clone 개발리소스 경로에서 git command를 이용하여 submodule 정보 update git submodule init git submodule update cd public git checkout main 작업시작 ","date":"2022-10-19T22:47:00Z","image":"https://blog.realsn.com/thumb.png","permalink":"https://blog.realsn.com/p/hugo-framework%EB%A1%9C-publishing-%ED%95%98%EA%B8%B0/","title":"Hugo Framework로 Publishing 하기"},{"content":"Hugo 공식문서의 설치법 링크에 접속하면 공식 문서의 다양한 설치법이 기재되어 있습니다.\n하지만 패키지 관리자를 설치하는 과정, CLI를 이용하는 등의 과정이 번거로워 Windows환경에서 직접 설치하는 법을 기재합니다 Windows에서 패키지 관리자 없이 설치하는 법 링크에 접속하면 빌드 되어있는 휴고의 release를 확인할 수 있습니다. 해당 페이지에서 원하는 버전에 해당하는 Release를 찾습니다.\n본 게시글을 작성하는 시점의 최신버전 : v0.104.1\n본 게시글을 빌드한 버전 : v0.103.1 하단에 Assets 메뉴를 클릭하여 펼친 후 \u0026lsquo;Show all nn assets\u0026rsquo;를 클릭합니다.\n0.104.1버전의 경우 'Show all 23 assets' \u0026lsquo;hugo_extended_version_windows-amd64.zip\u0026rsquo;을 클릭하여 다운 받습니다. 다운받은 압축파일의 압축을 풀고 \u0026lsquo;hugo.exe\u0026rsquo; 파일을 경로(C:\\Hugo\\bin)에 넣습니다.\nHugo Document에서는 'C:\\Hugo\\bin'을 기본 경로로 설명하고 있기에 본 설명은 해당 경로에 설치합니다 링크를 참조하여 환경 변수 편집에 들어갑니다. 환경 변수에 C:\\Hugo\\bin경로를 추가하면 설치가 모두 완료되었습니다.\n본 글에서 설명한 경로가 아닌 다른 경로에 'hugo.exe'를 넣었다면 해당하는 경로를 입력해주세요 올바르게 설치되었는지 확인하는 법 명령프롬프트(CMD)를 실행해줍니다. hugo version 명령어를 실행한 뒤 아래와 같이 나타나는지 확인합니다. 아래의 사진이 잘 보이지 않는다면 우클릭 후 '새 탭에서 이미지 열기'로 연 뒤 보는것을 권장합니다 위의 사진 처럼 휴고의 버전이 나오지 않는다면 설치가 되지 않은 것이므로 처음부터 다시 해보는 것을 권장합니다. ","date":"2022-09-29T09:48:00Z","image":"https://blog.realsn.com/p/hugo-framework-%EC%84%A4%EC%B9%98/thumb_hu7a40aff17dad05f5d5a0240715286247_238394_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/hugo-framework-%EC%84%A4%EC%B9%98/","title":"Hugo Framework 설치"},{"content":"\nHugo Framework를 선택한 이유에 대하여 간단하게 정리하여 작성하겠습니다.\n목차 Client Side와 Server Side에 대한 간략한 설명 Web Server와 Web Application Server에 대한 간략한 설명 그래서 왜 Hugo Framework를 선택하게 되었는지? 예시페이지를 JSP와 Hugo로 작성했을때의 샘플 코드 예시페이지의 실행 결과 Hugo Framework의 Directory 구조와 반자동 배포에 대하여 정의 Client Side는 클라이언트(사용자)환경에서 처리되는 것이라고 할 수 있습니다. HTML, CSS, JavaScript 등을 예로 들 수 있습니다. Server Side는 서버환경에서 처리하는 것이라고 할 수 있습니다. 대표적으로 JSP, ASP.Net, PHP 등 프로그래밍 언어로 만들어진 파일들을 예로 들 수 있습니다. 처리과정 Client Side는 사용자가 HTTP요청에 따라 파일을 전달받아 그 파일 내의 코드를 웹브라우저가 직접 해석하고 화면을 렌더링하여 사용자에게 보여줍니다. Server Side는 서버의 WAS에서 코드를 해석한 뒤 HTML 형식으로 빌드하여 사용자에게 넘겨주는 과정이 추가됩니다. 배포과정 Cleint Side는 정적페이지로 이루어져 있고 그 내용은 사용자의 웹브라우저가 해석이 가능하므로 단순한 Web Server만으로도 배포가 가능합니다. Server Side는 동적페이지로 이루어져 있고 사용자의 웹브라우저에서 단독으로 해석이 불가능하기 때문에 WAS를 이용한 배포만 가능합니다. 정의 Web Server는 사용자로부터 HTTP요청을 수신한 뒤 경로에 해당하는 정적 리소스를 반환합니다. 대표적으로 Apache Server, GitHub Pages 등이 있습니다. Web Apllication Server는 Web Server의 기능에 동적 리소스를 정적 리소스로 변환하여 사용자에게 반환할 수 있습니다. 대표적으로 Apache Tomcat, NginX 등이 있습니다. 목적 Web Server는 서버 측에 저장된 파일 중에서 HTML, CSS, JS, 이미지 등 상태가 변하지 않는 정적 리소스만을 사용자에게 반환할 수 있습니다. Web Apllication Server는 Server Side언어로 만들어진 동적 리소스들을 정적 리소스로 변환하여 전달할 수 있습니다. 처리 환경 Web Server는 정적 리소스만을 취급하기 때문에 로컬 환경에서 테스트를 진행할 때에는 굳이 Web Server를 동작시킬 필요 없이 웹브라우저에서 단독으로 테스트가 가능합니다. Web Apllication Server는 동적 리소스를 취급할 때에 있어서 필수적인 요소로 작용하기 때문에 동적 리소스를 취급함에 있어서 WAS는 필수적으로 동작되어야 합니다. Client Side로 이루어져 있습니다.\nHugo의 빌드 결과물은 정적 리소스로 이루어져 있어 WAS를 사용하지 않고 로컬 환경에서 손쉽게 테스트가 가능하며 Web Server만을 이용하여 간편하게 배포가 가능합니다. SASS 통합 컴파일, JavaScript 번들링을 지원합니다.\nHugo는 자체적으로 SASS 컴파일과 JavaScript 번들링하여 빌드할 수 있습니다. 기존에 SASS를 작성하여 컴파일하고, JavaScript를 번들링한 뒤 WAS를 통하여 리소스를 배포하였다면, Hugo를 사용할 때에는 설정만 해둔다면 Hugo명령어를 통하여 한 번에 처리가 가능합니다. 정적 리소스임에도 불구하고 Layout을 구성해두면 지속적으로 재사용이 가능합니다.\nHugo는 header, footer등 미리 만들어둔 파일을 partial을 통하여 불러와서 사용할 수 있습니다. 기존에는 include 기능을 사용하기 위하여 jsp를 이용하여 산출물을 만들었고 그렇기 때문에 WAS를 이용하여야만 했습니다. Git을 활용하면 형상관리와 배포를 동시에 처리할 수 있습니다.\nHugo는 Git을 이용한다면 아주 간편하게 공유 및 배포가 가능합니다. 기존에는 WAS를 통해서만 산출물을 배포할 수 있었지만 Hugo는 Git의 Submodule 기능을 활용한다면 소스코드와 산출물을 분리하여 관리, 배포할 수 있고 이 과정을 스크립트를 통해 '반 자동화'하여 편리하게 이용할 수 있습니다. 종합 - 기존 산출물을 테스트하기 위해서는 JDK, Apache Tomcat을 설치하여야 했고, Apache Tomcat을 실행시켜둬야함 SASS 컴파일, JavaScript 번들링 등의 과정을 별도로 거쳤어야함 종합 - Hugo 산출물을 로컬에서 테스트 할 때에는 Hugo가 설치된 상태로 hugo server명령어만 입력하면 실시간으로 테스트 가능 SASS 컴파일, JavaScript 번들링 또한 Hugo 빌드 시 자체적으로 처리(extended 버전 한정) JSP 샘플코드\n페이지 최상단에 jsp 선언을 합니다. html 구조를 작성합니다. 삽입되어질 페이지를 include 합니다. 각 페이지에 맞는 컨텐츠를 작성합니다. Hugo 샘플코드\nbaseof.html에 기본적인 html구조 및 partial을 작성합니다. single.html에 컨텐츠 영역을 설정합니다. index.html에 Front Matter(--- ---)를 작성한 뒤 컨텐츠를 작성합니다. 차이점\nJSP의 경우에는 페이지가 늘어나면 각 페이지마다 상기 1~4번의 과정을 계속해서 거쳐야 합니다. Hugo의 경우에는 3번의 과정인 Front Matter를 작성하고 컨텐츠를 작성하면 1~2번에 작성한 내용이 자동으로 재사용 됩니다. 위 화면은 상기 샘플코드를 실행했을 때의 결과이며, 2개의 코드 모두 결과는 동일합니다.\nHugo Site의 폴더구조 및 반자동 배포\n좌측은 Hugo Framework을 이용하여 만든 Site의 기본적인 Directory Structure이며 링크에서 더 자세히 알아볼 수 있습니다.\n우측은 쉘 스크립트를 이용하여 커밋메시지만 입력하면 Hugo로 만들어진 사이트를 빌드하고 결과물과 소스코드를 각각 git에 push하는 반 자동화 배포 스크립트 입니다.\n","date":"2022-09-28T10:25:00Z","image":"https://blog.realsn.com/p/hugo-framework%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/thumb_hu7a40aff17dad05f5d5a0240715286247_240140_120x120_fill_box_smart1_3.png","permalink":"https://blog.realsn.com/p/hugo-framework%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0/","title":"Hugo Framework를 선택하게 된 이유"}]